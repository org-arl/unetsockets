{"version":3,"file":"unetjs.min.js","sources":["../node_modules/fjage/dist/esm/fjage.js","../src/unetutils.js","../src/unetsocket.js"],"sourcesContent":["/* fjage.js v2.2.1 */\n\n/**\n* An action represented by a message. The performative actions are a subset of the\n* FIPA ACL recommendations for interagent communication.\n* @enum {string}\n*/\nconst Performative = {\n  REQUEST: 'REQUEST',               // Request an action to be performed\n  AGREE: 'AGREE',                   // Agree to performing the requested action\n  REFUSE: 'REFUSE',                 // Refuse to perform the requested action\n  FAILURE: 'FAILURE',               // Notification of failure to perform a requested or agreed action\n  INFORM: 'INFORM',                 // Notification of an event\n  CONFIRM: 'CONFIRM',               // Confirm that the answer to a query is true\n  DISCONFIRM: 'DISCONFIRM',         // Confirm that the answer to a query is false\n  QUERY_IF: 'QUERY_IF',             // Query if some statement is true or false\n  NOT_UNDERSTOOD: 'NOT_UNDERSTOOD', // Notification that a message was not understood\n  CFP: 'CFP',                       // Call for proposal\n  PROPOSE: 'PROPOSE',               // Response for CFP\n  CANCEL: 'CANCEL'                  // Cancel pending request\n};\n\n////// common utilities\n\n// generate random ID with length 4*len characters\n/**\n *\n * @private\n * @param {number} len\n */\nfunction _guid(len) {\n  const s4 = () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  return Array.from({ length: len }, s4).join('');\n}\n\n\n/**\n * A simple and lightweight implementation of UUIDv7.\n *\n * UUIDv7 is a time-based UUID version that is lexicographically sortable and\n * is designed to be used as a database key.\n *\n * The structure is as follows:\n * 0                   1                   2                   3\n * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                           unix_ts_ms                          |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |          unix_ts_ms           |  ver  |      rand_a           |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |var|                        rand_b                             |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                            rand_b                             |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * - unix_ts_ms (48 bits): Unix timestamp in milliseconds.\n * - ver (4 bits): Version, set to 7.\n * - rand_a (12 bits): Random data.\n * - var (2 bits): Variant, set to '10'.\n * - rand_b (62 bits): Random data.\n */\nclass UUID7 {\n    /**\n     * Private constructor to create a UUID7 from a byte array.\n     * @param {Uint8Array} bytes The 16 bytes of the UUID.\n     */\n    constructor(bytes) {\n        if (bytes.length !== 16) {\n            throw new Error('UUID7 must be constructed with a 16-byte array.');\n        }\n        this.bytes = bytes;\n    }\n\n    /**\n     * Generates a new UUIDv7.\n     * @returns {UUID7} A new UUIDv7 instance.\n     */\n    static generate() {\n        const bytes = new Uint8Array(16);\n        const randomBytes = crypto.getRandomValues(new Uint8Array(10));\n        const timestamp = Date.now();\n\n        // Set the 48-bit timestamp\n        // JavaScript numbers are 64-bit floats, but bitwise operations treat them\n        // as 32-bit signed integers. We need to handle the 48-bit timestamp carefully.\n        const timestampHi = Math.floor(timestamp / 2 ** 16);\n        const timestampLo = timestamp % 2 ** 16;\n\n        bytes[0] = (timestampHi >> 24) & 0xff;\n        bytes[1] = (timestampHi >> 16) & 0xff;\n        bytes[2] = (timestampHi >> 8) & 0xff;\n        bytes[3] = timestampHi & 0xff;\n        bytes[4] = (timestampLo >> 8) & 0xff;\n        bytes[5] = timestampLo & 0xff;\n\n        // Copy the 10 random bytes\n        bytes.set(randomBytes, 6);\n\n        // Set the 4-bit version (0111) in byte 6\n        bytes[6] = (bytes[6] & 0x0f) | 0x70;\n\n        // Set the 2-bit variant (10) in byte 8\n        bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n        return new UUID7(bytes);\n    }\n\n    /**\n     * Extracts the timestamp from the UUID.\n     * @returns {number} The Unix timestamp in milliseconds.\n     */\n    getTimestamp() {\n        let timestamp = 0;\n        timestamp = this.bytes[0] * 2 ** 40;\n        timestamp += this.bytes[1] * 2 ** 32;\n        timestamp += this.bytes[2] * 2 ** 24;\n        timestamp += this.bytes[3] * 2 ** 16;\n        timestamp += this.bytes[4] * 2 ** 8;\n        timestamp += this.bytes[5];\n        return timestamp;\n    }\n\n    /**\n     * Formats the UUID into the standard string representation.\n     * @returns {string} The UUID string.\n     */\n    toString() {\n        let result = '';\n        for (let i = 0; i < 16; i++) {\n            result += this.bytes[i].toString(16).padStart(2, '0');\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                result += '-';\n            }\n        }\n        return result;\n    }\n}\n\n// src/index.ts\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nvar isNode = (\n  // @ts-expect-error\n  typeof process !== \"undefined\" && // @ts-expect-error\n  process.versions != null && // @ts-expect-error\n  process.versions.node != null\n);\nvar isWebWorker = typeof self === \"object\" && self.constructor && self.constructor.name === \"DedicatedWorkerGlobalScope\";\nvar isJsDom = typeof window !== \"undefined\" && window.name === \"nodejs\" || typeof navigator !== \"undefined\" && \"userAgent\" in navigator && typeof navigator.userAgent === \"string\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n(\n  // @ts-expect-error\n  typeof Deno !== \"undefined\" && // @ts-expect-error\n  typeof Deno.version !== \"undefined\" && // @ts-expect-error\n  typeof Deno.version.deno !== \"undefined\"\n);\ntypeof process !== \"undefined\" && process.versions != null && process.versions.bun != null;\n\nconst SOCKET_OPEN = 'open';\nconst SOCKET_OPENING = 'opening';\nconst DEFAULT_RECONNECT_TIME$1 = 5000;       // ms, delay between retries to connect to the server.\n\nvar createConnection;\n\n/**\n* @class\n* @ignore\n*/\nclass TCPConnector {\n\n  /**\n  * Create an TCPConnector to connect to a fjage master over TCP\n  * @param {Object} opts\n  * @param {string} [opts.hostname='localhost'] - hostname/ip address of the master container to connect to\n  * @param {number} [opts.port=1100] - port number of the master container to connect to\n  * @param {boolean} [opts.keepAlive=true] - try to reconnect if the connection is lost\n  * @param {boolean} [opts.debug=false] - debug info to be logged to console?\n  * @param {number} [opts.reconnectTime=5000] - time before reconnection is attempted after an error\n  */\n  constructor(opts = {}) {\n    let host = opts.hostname || 'localhost';\n    let port = opts.port || 1100;\n    this._keepAlive = opts.keepAlive;\n    this._reconnectTime = opts.reconnectTime || DEFAULT_RECONNECT_TIME$1;\n    this.url = new URL('tcp://localhost');\n    this.url.hostname = host;\n    this.url.port = port.toString();\n    this._buf = '';\n    this._firstConn = true;               // if the Gateway has managed to connect to a server before\n    this._firstReConn = true;             // if the Gateway has attempted to reconnect to a server before\n    this.pendingOnOpen = [];              // list of callbacks make as soon as gateway is open\n    this.connListeners = [];              // external listeners wanting to listen connection events\n    this.debug = false;\n    this._sockInit(host, port);\n  }\n\n\n  _sendConnEvent(val) {\n    this.connListeners.forEach(l => {\n      l && {}.toString.call(l) === '[object Function]' && l(val);\n    });\n  }\n\n  _sockInit(host, port){\n    if (!createConnection){\n      try {\n        // @ts-ignore\n        import('net').then(module => {\n          createConnection = module.createConnection;\n          this._sockSetup(host, port);\n        });\n      }catch(error){\n        if(this.debug) console.log('Unable to import net module');\n      }\n    }else {\n      this._sockSetup(host, port);\n    }\n  }\n\n  _sockSetup(host, port){\n    if(!createConnection) return;\n    try{\n      this.sock = createConnection({ 'host': host, 'port': port });\n      this.sock.setEncoding('utf8');\n      this.sock.on('connect', this._onSockOpen.bind(this));\n      this.sock.on('error', this._sockReconnect.bind(this));\n      this.sock.on('close', () => {this._sendConnEvent(false);});\n      this.sock.send = data => {this.sock.write(data);};\n    } catch (error) {\n      if(this.debug) console.log('Connection failed to ', this.sock.host + ':' + this.sock.port);\n      return;\n    }\n  }\n\n  _sockReconnect(){\n    if (this._firstConn || !this._keepAlive || this.sock.readyState == SOCKET_OPENING || this.sock.readyState == SOCKET_OPEN) return;\n    if (this._firstReConn) this._sendConnEvent(false);\n    this._firstReConn = false;\n    setTimeout(() => {\n      this.pendingOnOpen = [];\n      this._sockSetup(this.url.hostname, this.url.port);\n    }, this._reconnectTime);\n  }\n\n  _onSockOpen() {\n    this._sendConnEvent(true);\n    this._firstConn = false;\n    this.sock.on('close', this._sockReconnect.bind(this));\n    this.sock.on('data', this._processSockData.bind(this));\n    this.pendingOnOpen.forEach(cb => cb());\n    this.pendingOnOpen.length = 0;\n    this._buf = '';\n  }\n\n  _processSockData(s){\n    this._buf += s;\n    var lines = this._buf.split('\\n');\n    lines.forEach((l, idx) => {\n      if (idx < lines.length-1){\n        if (l && this._onSockRx) this._onSockRx.call(this,l);\n      } else {\n        this._buf = l;\n      }\n    });\n  }\n\n  toString(){\n    let s = '';\n    s += 'TCPConnector [' + this.sock ? this.sock.remoteAddress.toString() + ':' + this.sock.remotePort.toString() : '' + ']';\n    return s;\n  }\n\n  /**\n  * Write a string to the connector\n  * @param {string} s - string to be written out of the connector to the master\n  * @return {boolean} - true if connect was able to write or queue the string to the underlying socket\n  */\n  write(s){\n    if (!this.sock || this.sock.readyState == SOCKET_OPENING){\n      this.pendingOnOpen.push(() => {\n        this.sock.send(s+'\\n');\n      });\n      return true;\n    } else if (this.sock.readyState == SOCKET_OPEN) {\n      this.sock.send(s+'\\n');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  * @callback TCPConnectorReadCallback\n  * @ignore\n  * @param {string} s - incoming message string\n  */\n\n  /**\n  * Set a callback for receiving incoming strings from the connector\n  * @param {TCPConnectorReadCallback} cb - callback that is called when the connector gets a string\n  */\n  setReadCallback(cb){\n    if (cb && {}.toString.call(cb) === '[object Function]') this._onSockRx = cb;\n  }\n\n  /**\n  * Add listener for connection events\n  * @param {function} listener - a listener callback that is called when the connection is opened/closed\n  */\n  addConnectionListener(listener){\n    this.connListeners.push(listener);\n  }\n\n  /**\n  * Remove listener for connection events\n  * @param {function} listener - remove the listener for connection\n  * @return {boolean} - true if the listner was removed successfully\n  */\n  removeConnectionListener(listener) {\n    let ndx = this.connListeners.indexOf(listener);\n    if (ndx >= 0) {\n      this.connListeners.splice(ndx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  * Close the connector\n  */\n  close(){\n    if (!this.sock) return;\n    if (this.sock.readyState == SOCKET_OPENING) {\n      this.pendingOnOpen.push(() => {\n        this.sock.send('{\"alive\": false}\\n');\n        this.sock.removeAllListeners('connect');\n        this.sock.removeAllListeners('error');\n        this.sock.removeAllListeners('close');\n        this.sock.destroy();\n      });\n    } else if (this.sock.readyState == SOCKET_OPEN) {\n      this.sock.send('{\"alive\": false}\\n');\n      this.sock.removeAllListeners('connect');\n      this.sock.removeAllListeners('error');\n      this.sock.removeAllListeners('close');\n      this.sock.destroy();\n    }\n  }\n}\n\nconst DEFAULT_RECONNECT_TIME = 5000;       // ms, delay between retries to connect to the server.\n\n/**\n* @class\n* @ignore\n*/\nclass WSConnector {\n\n  /**\n  * Create an WSConnector to connect to a fjage master over WebSockets\n  * @param {Object} opts\n  * @param {string} [opts.hostname='localhost'] - hostname/ip address of the master container to connect to\n  * @param {number} [opts.port=80] - port number of the master container to connect to\n  * @param {string} [opts.pathname=\"/\"] - path of the master container to connect to\n  * @param {boolean} [opts.keepAlive=true] - try to reconnect if the connection is lost\n  * @param {boolean} [opts.debug=false] - debug info to be logged to console?\n  * @param {number} [opts.reconnectTime=5000] - time before reconnection is attempted after an error\n  */\n  constructor(opts = {}) {\n    let host = opts.hostname || 'localhost';\n    let port = opts.port || 80;\n    this.url = new URL('ws://localhost');\n    this.url.hostname = host;\n    this.url.port = port.toString();\n    this.url.pathname = opts.pathname || '/';\n    this._keepAlive = opts.keepAlive;\n    this._reconnectTime = opts.reconnectTime || DEFAULT_RECONNECT_TIME;\n    this.debug = opts.debug || false;      // debug info to be logged to console?\n    this._firstConn = true;               // if the Gateway has managed to connect to a server before\n    this._firstReConn = true;             // if the Gateway has attempted to reconnect to a server before\n    this.pendingOnOpen = [];              // list of callbacks make as soon as gateway is open\n    this.connListeners = [];              // external listeners wanting to listen connection events\n    this._websockSetup(this.url);\n  }\n\n  _sendConnEvent(val) {\n    this.connListeners.forEach(l => {\n      l && {}.toString.call(l) === '[object Function]' && l(val);\n    });\n  }\n\n  _websockSetup(url){\n    try {\n      this.sock = new WebSocket(url);\n      this.sock.onerror = this._websockReconnect.bind(this);\n      this.sock.onopen = this._onWebsockOpen.bind(this);\n      this.sock.onclose = () => {this._sendConnEvent(false);};\n    } catch (error) {\n      if(this.debug) console.log('Connection failed to ', url);\n      return;\n    }\n  }\n\n  _websockReconnect(){\n    if (this._firstConn || !this._keepAlive || this.sock.readyState == this.sock.CONNECTING || this.sock.readyState == this.sock.OPEN) return;\n    if (this._firstReConn) this._sendConnEvent(false);\n    this._firstReConn = false;\n    if(this.debug) console.log('Reconnecting to ', this.sock.url);\n    setTimeout(() => {\n      this.pendingOnOpen = [];\n      this._websockSetup(this.sock.url);\n    }, this._reconnectTime);\n  }\n\n  _onWebsockOpen() {\n    if(this.debug) console.log('Connected to ', this.sock.url);\n    this._sendConnEvent(true);\n    this.sock.onclose = this._websockReconnect.bind(this);\n    this.sock.onmessage = event => { if (this._onWebsockRx) this._onWebsockRx.call(this,event.data); };\n    this._firstConn = false;\n    this._firstReConn = true;\n    this.pendingOnOpen.forEach(cb => cb());\n    this.pendingOnOpen.length = 0;\n  }\n\n  toString(){\n    let s = '';\n    s += 'WSConnector [' + this.sock ? this.sock.url.toString() : '' + ']';\n    return s;\n  }\n\n  /**\n  * Write a string to the connector\n  * @param {string} s - string to be written out of the connector to the master\n  */\n  write(s){\n    if (!this.sock || this.sock.readyState == this.sock.CONNECTING){\n      this.pendingOnOpen.push(() => {\n        this.sock.send(s+'\\n');\n      });\n      return true;\n    } else if (this.sock.readyState == this.sock.OPEN) {\n      this.sock.send(s+'\\n');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  * @callback WSConnectorReadCallback\n  * @ignore\n  * @param {string} s - incoming message string\n  */\n\n  /**\n  * Set a callback for receiving incoming strings from the connector\n  * @param {WSConnectorReadCallback} cb - callback that is called when the connector gets a string\n  * @ignore\n  */\n  setReadCallback(cb){\n    if (cb && {}.toString.call(cb) === '[object Function]') this._onWebsockRx = cb;\n  }\n\n  /**\n  * Add listener for connection events\n  * @param {function} listener - a listener callback that is called when the connection is opened/closed\n  */\n  addConnectionListener(listener){\n    this.connListeners.push(listener);\n  }\n\n  /**\n  * Remove listener for connection events\n  * @param {function} listener - remove the listener for connection\n  * @return {boolean} - true if the listner was removed successfully\n  */\n  removeConnectionListener(listener) {\n    let ndx = this.connListeners.indexOf(listener);\n    if (ndx >= 0) {\n      this.connListeners.splice(ndx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  * Close the connector\n  */\n  close(){\n    if (!this.sock) return;\n    if (this.sock.readyState == this.sock.CONNECTING) {\n      this.pendingOnOpen.push(() => {\n        this.sock.send('{\"alive\": false}\\n');\n        this.sock.onclose = null;\n        this.sock.close();\n      });\n    } else if (this.sock.readyState == this.sock.OPEN) {\n      this.sock.send('{\"alive\": false}\\n');\n      this.sock.onclose = null;\n      this.sock.close();\n    }\n  }\n}\n\n/* global Buffer */\n\n/**\n* Class representing a fjage's on-the-wire JSON message. A JSONMessage object\n* contains all the fields that can be a part of a fjage JSON message. The class\n* provides methods to create JSONMessage objects from raw strings and to\n* convert JSONMessage objects to JSON strings in the format of the fjage on-the-wire\n* protocol. See {@link https://fjage.readthedocs.io/en/latest/protocol.html#json-message-request-response-attributes fjage documentation}\n* for more details on the JSON message format.\n*\n* Most users will not need to create JSONMessage objects directly, but rather use the Gateway and Message classes\n* to send and receive messages. However, this class can be useful for low-level access to the fjage protocol\n* or for generating/consuming the fjåge protocol messages without having them be transmitted over a network.\n*\n* @example\n* const jsonMsg = new JSONMessage();\n* jsonMsg.action = 'send';\n* jsonMsg.message = new Message();\n* jsonMsg.message.sender = new AgentID('agent1');\n* jsonMsg.message.recipient = new AgentID('agent2');\n* jsonMsg.message.perf = Performative.INFORM;\n* jsonMsg.toJSON(); // Converts to JSON string in the fjage on-the-wire protocol format\n*\n* @example\n* const jsonString = '{\"id\":\"1234\",...}'; // JSON string representation of a JSONMessage\n* const jsonMsg = new JSONMessage(jsonString); // Parses the JSON string into a JSONMessage object\n* jsonMsg.message; // Access the Message object contained in the JSONMessage\n*\n* @class\n* @property {string} [id] - A UUID assigned to each JSONMessage object.\n* @property {string} [action] - Denotes the main action the object is supposed to perform.\n* @property {string} [inResponseTo] - This attribute contains the action to which this object is a response to.\n* @property {AgentID} [agentID] - An AgentID. This attribute is populated in objects which are responses to objects requesting the ID of an agent providing a specific service.\n* @property {Array<AgentID>} [agentIDs] - This attribute is populated in objects which are responses to objects requesting the IDs of agents providing a specific service, or objects which are responses to objects requesting a list of all agents running in a container.\n* @property {Array<string>} [agentTypes] - This attribute is optionally populated in objects which are responses to objects requesting a list of all agents running in a container. If populated, it contains a list of agent types running in the container, with a one-to-one mapping to the agent IDs in the \"agentIDs\" attribute.\n* @property {string} [service] - Used in conjunction with \"action\" : \"agentForService\" and \"action\" : \"agentsForService\" to query for agent(s) providing this specific service.\n* @property {Array<string>} [services] - This attribute is populated in objects which are responses to objects requesting the services available with \"action\" : \"services\".\n* @property {boolean} [answer] - This attribute is populated in objects which are responses to query objects with \"action\" : \"containsAgent\".\n* @property {Message} [message] - This holds the main payload of the message. The structure and format of this object is discussed in the {@link https://fjage.readthedocs.io/en/latest/protocol.html#json-message-request-response-attributes fjage documentation}.\n* @property {boolean} [relay] - This attribute defines if the target container should relay (forward) the message to other containers it is connected to or not.\n* @property {Object} [creds] - Credentials to be used for authentication.\n* @property {Object} [auth] - Authentication information to be used for the message.\n*\n*\n*/\nclass JSONMessage {\n\n  /**\n  * @param {String} [jsonString] - JSON string to be parsed into a JSONMessage object.\n  * @param {Object} [owner] - The owner of the JSONMessage object, typically the Gateway instance.\n  */\n  constructor(jsonString, owner) {\n    this.id = UUID7.generate().toString(); // unique JSON message ID\n    this.action =  null;\n    this.inResponseTo =  null;\n    this.agentID = null;\n    this.agentIDs = null;\n    this.agentTypes = null;\n    this.service =  null;\n    this.services = null;\n    this.answer =  null;\n    this.message = null;\n    this.relay =  null;\n    this.creds =  null;\n    this.auth =  null;\n    this.name =  null;\n    if (jsonString && typeof jsonString === 'string') {\n      try {\n        const parsed = JSON.parse(jsonString, _decodeBase64);\n        if (parsed.message) parsed.message = Message.fromJSON(parsed.message);\n        if (parsed.agentID) parsed.agentID = AgentID.fromJSON(parsed.agentID, owner);\n        if (parsed.agentIDs) parsed.agentIDs = parsed.agentIDs.map(id => AgentID.fromJSON(id, owner));\n        Object.assign(this, parsed);\n      } catch (e) {\n        throw new Error('Invalid JSON string: ' + e.message);\n      }\n    }  }\n\n  /**\n  * Creates a JSONMessage object to send a message.\n  *\n  * @param {Message} msg\n  * @param {boolean} [relay=false] - whether to relay the message\n  * @returns {JSONMessage} - JSONMessage object with request to send a message\n  */\n  static createSend(msg, relay=false){\n    if (!(msg instanceof Message)) {\n      throw new Error('Invalid message type');\n    }\n    const jsonMsg = new JSONMessage();\n    jsonMsg.action = Actions.SEND;\n    jsonMsg.relay = relay;\n    jsonMsg.message = msg;\n    return jsonMsg;\n  }\n\n  /**\n  * Creates a JSONMessage object to update WantsMessagesFor list.\n  *\n  * @param {Array<AgentID>} agentIDs - array of AgentID objects for which the gateway wants messages\n  * @returns {JSONMessage} - JSONMessage object with request to update WantsMessagesFor list\n  */\n  static createWantsMessagesFor(agentIDs) {\n    if (!Array.isArray(agentIDs) || agentIDs.length === 0) {\n      throw new Error('agentIDNames must be a non-empty array');\n    }\n    const jsonMsg = new JSONMessage();\n    jsonMsg.action = Actions.WANTS_MESSAGES_FOR;\n    jsonMsg.agentIDs = agentIDs;\n    return jsonMsg;\n  }\n\n  /**\n  * Creates a JSONMessage object to request the list of agents.\n  *\n  * @returns {JSONMessage} - JSONMessage object with request for the list of agents\n  */\n  static createAgents(){\n    const jsonMsg = new JSONMessage();\n    jsonMsg.action = Actions.AGENTS;\n    jsonMsg.id = UUID7.generate().toString(); // unique JSON message ID\n    return jsonMsg;\n  }\n\n  /**\n  * Creates a JSONMessage object to check if an agent is contained\n  *\n  * @param {AgentID} agentID - AgentID of the agent to check\n  * @returns {JSONMessage} - JSONMessage object with request to check if the agent is contained\n  */\n  static createContainsAgent(agentID) {\n    if (!(agentID instanceof AgentID)) {\n      throw new Error('agentID must be an instance of AgentID');\n    }\n    const jsonMsg = new JSONMessage();\n    jsonMsg.action = Actions.CONTAINS_AGENT;\n    jsonMsg.id = UUID7.generate().toString(); // unique JSON message ID\n    jsonMsg.agentID = agentID;\n    return jsonMsg;\n  }\n\n  /**\n  * Creates a JSONMessage object to get an agent for a service.\n  *\n  * @param {string} service - service which the agent must provide\n  * @returns {JSONMessage} - JSONMessage object with request for an agent providing the service\n  */\n  static createAgentForService(service) {\n    if (typeof service !== 'string' || service.length === 0) {\n      throw new Error('service must be a non-empty string');\n    }\n    const jsonMsg = new JSONMessage();\n    jsonMsg.action = Actions.AGENT_FOR_SERVICE;\n    jsonMsg.id = UUID7.generate().toString(); // unique JSON message ID\n    jsonMsg.service = service;\n    return jsonMsg;\n  }\n\n  /**\n  * Creates a JSONMessage object to get all agents for a service.\n  *\n  * @param {string} service - service which the agents must provide\n  * @returns {JSONMessage} - JSONMessage object with request for all agent providing the service\n  */\n  static createAgentsForService(service) {\n    if (typeof service !== 'string' || service.length === 0) {\n      throw new Error('service must be a non-empty string');\n    }\n    const jsonMsg = new JSONMessage();\n    jsonMsg.action = Actions.AGENTS_FOR_SERVICE;\n    jsonMsg.id = UUID7.generate().toString(); // unique JSON message ID\n    jsonMsg.service = service;\n    return jsonMsg;\n  }\n\n  /**\n  * Converts the JSONMessage object to a JSON string in the format of the\n  * fjage on-the-wire protocol. If the JSONMessage contains a Message or\n  * AgentID objects, they will be serialized as per the fjåge protocol.\n  *\n  * @returns {string} - JSON string representation of the message\n  */\n  toJSON() {\n    if (!this.action && !this.id) {\n      throw new Error('Neither action nor id is set. Cannot serialize JSONMessage.');\n    }\n    const jsonObj = {};\n    // Add property if not null or undefined\n    if (this.id) jsonObj.id = this.id;\n    if (this.action) jsonObj.action = this.action;\n    if (this.inResponseTo) jsonObj.inResponseTo = this.inResponseTo;\n    if (this.agentID) jsonObj.agentID = this.agentID.toJSON();\n    if (this.agentIDs) {\n      jsonObj.agentIDs = this.agentIDs.map(id => id.toJSON());\n      if (jsonObj.agentIDs.length === 0) delete jsonObj.agentIDs; // remove empty array\n    }\n    if (this.service) jsonObj.service = this.service;\n    if (this.services) {\n      jsonObj.services = this.services;\n      if (jsonObj.services.length === 0) delete jsonObj.services; // remove empty array\n    }\n    if (this.answer) jsonObj.answer = this.answer;\n    if (this.message) jsonObj.message = this.message;\n    if (this.relay) jsonObj.relay = this.relay;\n    if (this.creds) jsonObj.creds = this.creds;\n    if (this.auth) jsonObj.auth = this.auth;\n    if (this.name) jsonObj.name = this.name;\n    return JSON.stringify(jsonObj);\n  }\n\n  toString() {\n    return this.toJSON();\n  }\n}\n\n\n/**\n* Actions supported by the fjåge JSON message protocol. See\n* {@link https://fjage.readthedocs.io/en/latest/protocol.html#json-message-request-response-attributes fjage documentation} for more details.\n*\n* @enum {string} Actions\n*/\nconst Actions = {\n  AGENTS : 'agents',\n  CONTAINS_AGENT : 'containsAgent',\n  AGENT_FOR_SERVICE : 'agentForService',\n  AGENTS_FOR_SERVICE : 'agentsForService',\n  SEND : 'send',\n  WANTS_MESSAGES_FOR : 'wantsMessagesFor'};\n\n////// private utilities\n\n\n/**\n* Decode large numeric arrays encoded in base64 back to array format.\n*\n* @private\n*\n* @param {string} _k - key (unused)\n* @param {any} d - data\n* @returns {Array} - decoded data in array format\n* */\nfunction _decodeBase64(_k, d) {\n  if (d === null) return null;\n  if (typeof d == 'object' && 'clazz' in d && 'data' in d && d.clazz.startsWith('[') && d.clazz.length == 2) {\n    return _b64toArray(d.data, d.clazz) || d;\n  }\n  return d;\n}\n\n/**\n* Convert a base64 encoded string to an array of numbers of the specified data type.\n*\n* @private\n*\n* @param {string} base64 - base64 encoded string\n* @param {string} dtype - data type, e.g. '[B' for byte array, '[S' for short array, etc.\n* @param {boolean} [littleEndian=true] - whether to use little-endian byte order\n*/\nfunction _b64toArray(base64, dtype, littleEndian=true) {\n  let s = _atob(base64);\n  let len = s.length;\n  let bytes = new Uint8Array(len);\n  for (var i = 0; i < len; i++)\n    bytes[i] = s.charCodeAt(i);\n  let rv = [];\n  let view = new DataView(bytes.buffer);\n  switch (dtype) {\n    case '[B': // byte array\n    for (i = 0; i < len; i++)\n      rv.push(view.getUint8(i));\n    break;\n    case '[S': // short array\n    for (i = 0; i < len; i+=2)\n      rv.push(view.getInt16(i, littleEndian));\n    break;\n    case '[I': // integer array\n    for (i = 0; i < len; i+=4)\n      rv.push(view.getInt32(i, littleEndian));\n    break;\n    case '[J': // long array\n    for (i = 0; i < len; i+=8)\n      rv.push(view.getBigInt64(i, littleEndian));\n    break;\n    case '[F': // float array\n    for (i = 0; i < len; i+=4)\n      rv.push(view.getFloat32(i, littleEndian));\n    break;\n    case '[D': // double array\n    for (i = 0; i < len; i+=8)\n      rv.push(view.getFloat64(i, littleEndian));\n    break;\n    default:\n    return;\n  }\n  return rv;\n}\n\n// node.js safe atob function\n/**\n* @private\n* @param {string} a\n*/\nfunction _atob(a){\n  if (isBrowser || isWebWorker) return window.atob(a);\n  else if (isJsDom || isNode) return Buffer.from(a, 'base64').toString('binary');\n}\n\n/* global global */\n\n\nconst DEFAULT_QUEUE_SIZE = 128;        // max number of old unreceived messages to store\nconst DEFAULT_TIMEOUT$1 = 10000;         // default timeout for requests in milliseconds\n\nconst GATEWAY_DEFAULTS = {\n  'timeout': DEFAULT_TIMEOUT$1,\n  'keepAlive' : true,\n  'queueSize': DEFAULT_QUEUE_SIZE,\n  'returnNullOnFailedResponse': true\n};\n\nlet DEFAULT_URL;\nlet gObj = {};\n\n/**\n*\n* @private\n*\n* Initializes the Gateway module. This function should be called before using the Gateway class.\n* It sets up the default values for the Gateway and initializes the global object.\n* It also sets up the default URL for the Gateway based on the environment (browser, Node.js, etc.).\n* @returns {void}\n*/\nfunction init(){\n  if (isBrowser || isWebWorker){\n    gObj = window;\n    Object.assign(GATEWAY_DEFAULTS, {\n      'hostname': gObj.location.hostname,\n      'port': gObj.location.port,\n      'pathname' : '/ws/'\n    });\n    DEFAULT_URL = new URL('ws://localhost');\n    // Enable caching of Gateways in browser\n    if (typeof gObj.fjage === 'undefined') gObj.fjage = {};\n    if (typeof gObj.fjage.gateways == 'undefined') gObj.fjage.gateways = [];\n  } else if (isJsDom || isNode){\n    gObj = global;\n    Object.assign(GATEWAY_DEFAULTS, {\n      'hostname': 'localhost',\n      'port': '1100',\n      'pathname': ''\n    });\n    DEFAULT_URL = new URL('tcp://localhost');\n  }\n}\n\n/**\n* A gateway for connecting to a fjage master container. This class provides methods to\n* send and receive messages, subscribe to topics, and manage connections to the master container.\n* It can be used to connect to a fjage master container over WebSockets or TCP.\n*\n* @example <caption>Connects to the localhost:1100</caption>\n* const gw = new Gateway({ hostname: 'localhost', port: 1100 });\n*\n* @example <caption>Connects to the origin</caption>\n* const gw = new Gateway();\n*\n* @class\n* @property {AgentID} aid - agent id of the gateway\n* @property {boolean} connected - true if the gateway is connected to the master container\n* @property {boolean} debug - true if debug messages should be logged to the console\n*\n* Constructor arguments:\n* @param {Object} opts\n* @param {string} [opts.hostname=\"localhost\"] - hostname/ip address of the master container to connect to\n* @param {number} [opts.port=1100]          - port number of the master container to connect to\n* @param {string} [opts.pathname=\"\"]        - path of the master container to connect to (for WebSockets)\n* @param {boolean} [opts.keepAlive=true]     - try to reconnect if the connection is lost\n* @param {number} [opts.queueSize=128]      - size of the _queue of received messages that haven't been consumed yet\n* @param {number} [opts.timeout=10000]       - timeout for fjage level messages in ms\n* @param {boolean} [opts.returnNullOnFailedResponse=true] - return null instead of throwing an error when a parameter is not found\n* @param {boolean} [opts.cancelPendingOnDisconnect=false] - cancel pending requests on disconnects\n*/\nclass Gateway {\n\n  constructor(opts = {}) {\n    // Similar to Object.assign but also overwrites `undefined` and empty strings with defaults\n    for (var key in GATEWAY_DEFAULTS){\n      if (opts[key] == undefined || opts[key] === '') opts[key] = GATEWAY_DEFAULTS[key];\n    }\n    var url = DEFAULT_URL;\n    url.hostname = opts.hostname;\n    url.port = opts.port;\n    url.pathname = opts.pathname;\n    let existing = this._getGWCache(url);\n    if (existing) return existing;\n    this._timeout = opts.timeout;         // timeout for fjage level messages (agentForService etc)\n    this._keepAlive = opts.keepAlive;     // reconnect if connection gets closed/errored\n    this._queueSize = opts.queueSize;     // size of _queue\n    this._returnNullOnFailedResponse = opts.returnNullOnFailedResponse; // null or error\n    this._cancelPendingOnDisconnect = opts.cancelPendingOnDisconnect; // cancel pending requests on disconnect\n    this._pending_actions = {};            // msgid to callback mapping for pending actions\n    this._subscriptions = {};              // map for all topics that are subscribed\n    this._pending_receives = {};           // uuid to callbacks mapping for pending receives\n    this._eventListeners = {};             // external listeners wanting to listen internal events\n    this._queue = [];                      // incoming message _queue\n    this.connected = false;               // connection status\n    this.debug = false;                   // debug info to be logged to console?\n    this.aid = new AgentID('gateway-'+_guid(4));         // gateway agent name\n    this.connector = this._createConnector(url);\n    this._addGWCache(this);\n  }\n\n  /**\n  * Sends an event to all registered listeners of the given type.\n  * @private\n  * @param {string} type - type of event\n  * @param {Object|Message|string} val - value to be sent to the listeners\n  */\n  _sendEvent(type, val) {\n    if (!Array.isArray(this._eventListeners[type])) return;\n    this._eventListeners[type].forEach(l => {\n      if (l && {}.toString.call(l) === '[object Function]'){\n        try {\n          l(val);\n        } catch (error) {\n          console.warn('Error in event listener : ' + error);\n        }\n      }\n    });\n  }\n\n  /**\n  * Sends the message to all registered receivers.\n  *\n  * @private\n  * @param {Message} msg\n  * @returns {boolean} - true if the message was consumed by any listener\n  */\n  _sendReceivers(msg) {\n    for (var lid in this._pending_receives){\n      try {\n        if (this._pending_receives[lid] && this._pending_receives[lid](msg)) return true;\n      } catch (error) {\n        console.warn('Error in listener : ' + error);\n      }\n    }\n    return false;\n  }\n\n\n  /**\n  * @private\n  * @param {string} data - stringfied JSON data received from the master container to be processed\n  * @returns {void}\n  */\n  _onMsgRx(data) {\n    var jsonMsg;\n    if (this.debug) console.log('< '+data);\n    this._sendEvent('rx', data);\n    try {\n      jsonMsg = new JSONMessage(data, this);\n    }catch(e){\n      return;\n    }\n    this._sendEvent('rxp', jsonMsg);\n    if (jsonMsg.id && jsonMsg.id in this._pending_actions) {\n      // response to a pending request to master\n      this._pending_actions[jsonMsg.id](jsonMsg);\n      delete this._pending_actions[jsonMsg.id];\n    } else if (jsonMsg.action == Actions.SEND) {\n      // incoming message from master\n      const msg = jsonMsg.message;\n      if (!msg) return;\n      this._sendEvent('rxmsg', msg);\n      if ((msg.recipient.toJSON() == this.aid.toJSON())|| this._subscriptions[msg.recipient.toJSON()]) {\n        // send to any \"message\" listeners\n        this._sendEvent('message', msg);\n        // send message to receivers, if not consumed, add to _queue\n        if(!this._sendReceivers(msg)) {\n          if (this._queue.length >= this._queueSize) this._queue.shift();\n          this._queue.push(msg);\n        }\n      }\n    } else {\n      // respond to standard requests that every gateway must\n      let rsp = new JSONMessage();\n      rsp.id = jsonMsg.id;\n      rsp.inResponseTo = jsonMsg.action;\n      switch (jsonMsg.action) {\n        case 'agents':\n        rsp.agentIDs = [this.aid];\n        break;\n        case 'containsAgent':\n        rsp.answer = (jsonMsg.agentID.toJSON() == this.aid.toJSON());\n        break;\n        case 'services':\n        rsp.services = [];\n        break;\n        case 'agentForService':\n        rsp.agentID = '';\n        break;\n        case 'agentsForService':\n        rsp.agentIDs = [];\n        break;\n        default:\n        rsp = undefined;\n      }\n      if (rsp) this._msgTx(rsp);\n    }\n  }\n\n  /**\n  * Sends a message out to the master container. This method is used for sending\n  * fjage level actions that do not require a response, such as alive, wantMessages, etc.\n  * @private\n  * @param {JSONMessage} msg - JSONMessage to be sent to the master container\n  * @returns {boolean} - true if the message was sent successfully\n  */\n  _msgTx(msg) {\n    const s = msg.toJSON();\n    if(this.debug) console.log('> '+s);\n    this._sendEvent('tx', s);\n    return this.connector.write(s);\n  }\n\n  /**\n  * Send a message to the master container and wait for a response. This method is used for sending\n  * fjage level actions that require a response, such as agentForService, agents, etc.\n  * @private\n  * @param {JSONMessage} rq - JSONMessage to be sent to the master container\n  * @param {number} [timeout=opts.timeout] - timeout in milliseconds for the response\n  * @returns {Promise<JSONMessage|null>} - a promise which returns the response from the master container\n  */\n  _msgTxRx(rq, timeout = this._timeout) {\n    rq.id = UUID7.generate().toString();\n    return new Promise(resolve => {\n      let timer;\n      if (timeout >= 0){\n        timer = setTimeout(() => {\n          delete this._pending_actions[rq.id];\n          if (this.debug) console.log('Receive Timeout : ' + JSON.stringify(rq));\n          resolve(null);\n        }, timeout);\n      }\n      this._pending_actions[rq.id] = rsp => {\n        if (timer) clearTimeout(timer);\n        resolve(rsp);\n      };\n      if (!this._msgTx.call(this,rq)) {\n        if(timer) clearTimeout(timer);\n        delete this._pending_actions[rq.id];\n        if (this.debug) console.log('Transmit Failure : ' +  JSON.stringify(rq));\n        resolve(null);\n      }\n    });\n  }\n\n  /**\n  * @private\n  * @param {URL} url - URL object of the master container to connect to\n  * @returns {TCPConnector|WSConnector} - connector object to connect to the master container\n  */\n  _createConnector(url){\n    let conn;\n    if (url.protocol.startsWith('ws')){\n      conn =  new WSConnector({\n        'hostname':url.hostname,\n        'port':parseInt(url.port),\n        'pathname':url.pathname,\n        'keepAlive': this._keepAlive,\n        'debug': this.debug\n      });\n    }else if (url.protocol.startsWith('tcp')){\n      conn = new TCPConnector({\n        'hostname':url.hostname,\n        'port':parseInt(url.port),\n        'keepAlive': this._keepAlive,\n        'debug': this.debug\n      });\n    } else return null;\n    conn.setReadCallback(this._onMsgRx.bind(this));\n    conn.addConnectionListener(state => {\n      this.connected = !!state;\n      if (state == true){\n        this.flush();\n        this.connector.write('{\"alive\": true}');\n        this._update_watch();\n      } else {\n        if (this._cancelPendingOnDisconnect) {\n          this._sendReceivers(null);\n          this.flush();\n        }\n      }\n      this._sendEvent('conn', state);\n    });\n    return conn;\n  }\n\n  /**\n  * Checks if the object is a constructor.\n  *\n  * @private\n  * @param {Object} value - an object to be checked if it is a constructor\n  * @returns {boolean} - if the object is a constructor\n  */\n  _isConstructor(value) {\n    try {\n      new new Proxy(value, {construct() { return {}; }});\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n  * Matches a message with a filter.\n  * @private\n  * @param {string|Object|function} filter - filter to be matched\n  * @param {Message} msg - message to be matched to the filter\n  * @returns {boolean} - true if the message matches the filter\n  */\n  _matchMessage(filter, msg){\n    if (typeof filter == 'string' || filter instanceof String) {\n      return 'inReplyTo' in msg && msg.inReplyTo == filter;\n    } else if (Object.prototype.hasOwnProperty.call(filter, 'msgID')) {\n      return 'inReplyTo' in msg && msg.inReplyTo == filter.msgID;\n    } else if (filter.__proto__.name == 'Message' || filter.__proto__.__proto__.name == 'Message') {\n      return filter.__clazz__ == msg.__clazz__;\n    } else if (typeof filter == 'function' && !this._isConstructor(filter)) {\n      try {\n        return filter(msg);\n      }catch(e){\n        console.warn('Error in filter : ' + e);\n        return false;\n      }\n    } else {\n      return msg instanceof filter;\n    }\n  }\n\n  /**\n  * Gets the next message from the _queue that matches the filter.\n  * @private\n  * @param {string|Object|function} filter - filter to be matched\n  */\n  _getMessageFromQueue(filter) {\n    if (!this._queue.length) return;\n    if (!filter) return this._queue.shift();\n    let matchedMsg = this._queue.find( msg => this._matchMessage(filter, msg));\n    if (matchedMsg) this._queue.splice(this._queue.indexOf(matchedMsg), 1);\n    return matchedMsg;\n  }\n\n  /**\n  * Gets a cached gateway object for the given URL (if it exists).\n  * @private\n  * @param {URL} url - URL object of the master container to connect to\n  * @returns {Gateway|void} - gateway object for the given URL\n  */\n  _getGWCache(url){\n    if (!gObj.fjage || !gObj.fjage.gateways) return null;\n    var f = gObj.fjage.gateways.filter(g => g.connector.url.toString() == url.toString());\n    if (f.length ) return f[0];\n    return null;\n  }\n\n  /**\n  * Adds a gateway object to the cache if it doesn't already exist.\n  * @private\n  * @param {Gateway} gw - gateway object to be added to the cache\n  */\n  _addGWCache(gw){\n    if (!gObj.fjage || !gObj.fjage.gateways) return;\n    gObj.fjage.gateways.push(gw);\n  }\n\n  /**\n  * Removes a gateway object from the cache if it exists.\n  * @private\n  * @param {Gateway} gw - gateway object to be removed from the cache\n  */\n  _removeGWCache(gw){\n    if (!gObj.fjage || !gObj.fjage.gateways) return;\n    var index = gObj.fjage.gateways.indexOf(gw);\n    if (index != null) gObj.fjage.gateways.splice(index,1);\n  }\n\n  /** @private */\n  _update_watch() {\n    let watch = Object.keys(this._subscriptions);\n    watch.push(this.aid.toJSON());\n    const jsonMsg = JSONMessage.createWantsMessagesFor(watch.map(id => AgentID.fromJSON(id)));\n    this._msgTx(jsonMsg);\n  }\n\n  /**\n  * Add an event listener to listen to various events happening on this Gateway\n  *\n  * @param {string} type - type of event to be listened to\n  * @param {function} listener - new callback/function to be called when the event happens\n  * @returns {void}\n  */\n  addEventListener(type, listener) {\n    if (!Array.isArray(this._eventListeners[type])){\n      this._eventListeners[type] = [];\n    }\n    this._eventListeners[type].push(listener);\n  }\n\n  /**\n  * Remove an event listener.\n  *\n  * @param {string} type - type of event the listener was for\n  * @param {function} listener - callback/function which was to be called when the event happens\n  * @returns {void}\n  */\n  removeEventListener(type, listener) {\n    if (!this._eventListeners[type]) return;\n    let ndx = this._eventListeners[type].indexOf(listener);\n    if (ndx >= 0) this._eventListeners[type].splice(ndx, 1);\n  }\n\n  /**\n  * Add a new listener to listen to all {Message}s sent to this Gateway\n  *\n  * @param {function} listener - new callback/function to be called when a {Message} is received\n  * @returns {void}\n  */\n  addMessageListener(listener) {\n    this.addEventListener('message',listener);\n  }\n\n  /**\n  * Remove a message listener.\n  *\n  * @param {function} listener - removes a previously registered listener/callback\n  * @returns {void}\n  */\n  removeMessageListener(listener) {\n    this.removeEventListener('message', listener);\n  }\n\n  /**\n  * Add a new listener to get notified when the connection to master is created and terminated.\n  *\n  * @param {function} listener - new callback/function to be called connection to master is created and terminated\n  * @returns {void}\n  */\n  addConnListener(listener) {\n    this.addEventListener('conn', listener);\n  }\n\n  /**\n  * Remove a connection listener.\n  *\n  * @param {function} listener - removes a previously registered listener/callback\n  * @returns {void}\n  */\n  removeConnListener(listener) {\n    this.removeEventListener('conn', listener);\n  }\n\n  /**\n  * Gets the agent ID associated with the gateway.\n  *\n  * @returns {AgentID} - agent ID\n  */\n  getAgentID() {\n    return this.aid;\n  }\n\n  /**\n  * Get an AgentID for a given agent name.\n  *\n  * @param {string} name - name of agent\n  * @returns {AgentID} - AgentID for the given name\n  */\n  agent(name) {\n    return new AgentID(name, false, this);\n  }\n\n  /**\n  * Returns an object representing the named topic.\n  *\n  * @param {string|AgentID} topic - name of the topic or AgentID\n  * @param {string} [topic2] - name of the topic if the topic param is an AgentID\n  * @returns {AgentID} - object representing the topic\n  */\n  topic(topic, topic2) {\n    if (typeof topic == 'string' || topic instanceof String) return new AgentID(topic, true, this);\n    if (topic instanceof AgentID) {\n      if (topic.isTopic()) return topic;\n      return new AgentID(topic.getName()+(topic2 ? '__' + topic2 : '')+'__ntf', true, this);\n    }\n  }\n\n  /**\n  * Subscribes the gateway to receive all messages sent to the given topic.\n  *\n  * @param {AgentID} topic - the topic to subscribe to\n  * @returns {boolean} - true if the subscription is successful, false otherwise\n  */\n  subscribe(topic) {\n    if (!topic.isTopic()) topic = new AgentID(topic.getName() + '__ntf', true, this);\n    this._subscriptions[topic.toJSON()] = true;\n    this._update_watch();\n    return true;\n  }\n\n  /**\n  * Unsubscribes the gateway from a given topic.\n  *\n  * @param {AgentID} topic - the topic to unsubscribe\n  * @returns {void}\n  */\n  unsubscribe(topic) {\n    if (!topic.isTopic()) topic = new AgentID(topic.getName() + '__ntf', true, this);\n    delete this._subscriptions[topic.toJSON()];\n    this._update_watch();\n  }\n\n  /**\n  * Gets a list of all agents in the container.\n  * @param {number} [timeout=opts.timeout] - timeout in milliseconds\n  * @returns {Promise<AgentID[]>} - a promise which returns an array of all agent ids when resolved\n  */\n  async agents(timeout=this._timeout) {\n    let jsonMsg = JSONMessage.createAgents();\n    let rsp = await this._msgTxRx(jsonMsg, timeout);\n    if (!rsp || !Array.isArray(rsp.agentIDs)) throw new Error('Unable to get agents');\n    return rsp.agentIDs;\n  }\n\n  /**\n  * Check if an agent with a given name exists in the container.\n  *\n  * @param {AgentID|string} agentID - the agent id to check\n  * @param {number} [timeout=opts.timeout] - timeout in milliseconds\n  * @returns {Promise<boolean>} - a promise which returns true if the agent exists when resolved\n  */\n  async containsAgent(agentID, timeout=this._timeout) {\n    let jsonMsg = JSONMessage.createContainsAgent(agentID instanceof AgentID ? agentID : new AgentID(agentID));\n    let rsp = await this._msgTxRx(jsonMsg, timeout);\n    if (!rsp) {\n      if (this._returnNullOnFailedResponse) return null;\n      else throw new Error('Unable to check if agent exists');\n    }\n    return !!rsp.answer;\n  }\n\n  /**\n  * Finds an agent that provides a named service. If multiple agents are registered\n  * to provide a given service, any of the agents' id may be returned.\n  *\n  * @param {string} service - the named service of interest\n  * @param {number} [timeout=opts.timeout] - timeout in milliseconds\n  * @returns {Promise<?AgentID>} - a promise which returns an agent id for an agent that provides the service when resolved\n  */\n  async agentForService(service, timeout=this._timeout) {\n    let jsonMsg = JSONMessage.createAgentForService(service);\n    let rsp = await this._msgTxRx(jsonMsg, timeout);\n    if (!rsp) {\n      if (this._returnNullOnFailedResponse) return null;\n      else throw new Error('Unable to get agent for service');\n    }\n    return rsp.agentID;\n  }\n\n  /**\n  * Finds all agents that provides a named service.\n  *\n  * @param {string} service - the named service of interest\n  * @param {number} [timeout=opts.timeout] - timeout in milliseconds\n  * @returns {Promise<AgentID[]>} - a promise which returns an array of all agent ids that provides the service when resolved\n  */\n  async agentsForService(service, timeout=this._timeout) {\n    let jsonMsg = JSONMessage.createAgentsForService(service);\n    let rsp = await this._msgTxRx(jsonMsg, timeout);\n    if (!rsp) {\n      if (this._returnNullOnFailedResponse) return null;\n      else throw new Error('Unable to get agents for service');\n    }\n    return rsp.agentIDs || [];\n  }\n\n  /**\n  * Sends a message to the recipient indicated in the message. The recipient\n  * may be an agent or a topic.\n  *\n  * @param {Message} msg - message to be sent\n  * @returns {boolean} - if sending was successful\n  */\n  send(msg) {\n    msg.sender = this.aid;\n    this._sendEvent('txmsg', msg);\n    const jsonMsg = JSONMessage.createSend(msg, true);\n    return !!this._msgTx(jsonMsg);\n  }\n\n  /**\n  * Flush the Gateway _queue for all pending messages. This drops all the pending messages.\n  * @returns {void}\n  *\n  */\n  flush() {\n    this._queue.length = 0;\n  }\n\n  /**\n  * Sends a request and waits for a response. This method returns a {Promise} which resolves when a response\n  * is received or if no response is received after the timeout.\n  *\n  * @param {Message} msg - message to send\n  * @param {number} [timeout=opts.timeout] - timeout in milliseconds\n  * @returns {Promise<Message|void>} - a promise which resolves with the received response message, null on timeout\n  */\n  async request(msg, timeout=this._timeout) {\n    this.send(msg);\n    return this.receive(msg, timeout);\n  }\n\n  /**\n  * Returns a response message received by the gateway. This method returns a {Promise} which resolves when\n  * a response is received or if no response is received after the timeout.\n  *\n  * @param {function|Message|typeof Message} filter - original message to which a response is expected, or a MessageClass of the type\n  * of message to match, or a closure to use to match against the message\n  * @param {number} [timeout=0] - timeout in milliseconds\n  * @returns {Promise<Message|void>} - received response message, null on timeout\n  */\n  async receive(filter, timeout=0) {\n    return new Promise(resolve => {\n      let msg = this._getMessageFromQueue.call(this,filter);\n      if (msg) {\n        resolve(msg);\n        return;\n      }\n      if (timeout == 0) {\n        if (this.debug) console.log('Receive Timeout : ' + filter);\n        resolve();\n        return;\n      }\n      let lid = UUID7.generate().toString();\n      let timer;\n      if (timeout > 0){\n        timer = setTimeout(() => {\n          this._pending_receives[lid] && delete this._pending_receives[lid];\n          if (this.debug) console.log('Receive Timeout : ' + filter);\n          resolve();\n        }, timeout);\n      }\n      // listener for each pending receive\n      this._pending_receives[lid] = msg => {\n        // skip if the message does not match the filter\n        if (msg && !this._matchMessage(filter, msg)) return false;\n        if(timer) clearTimeout(timer);\n        // if the message matches the filter or is null, delete listener clear timer and resolve\n        this._pending_receives[lid] && delete this._pending_receives[lid];\n        resolve(msg);\n        return true;\n      };\n    });\n  }\n\n  /**\n  * Closes the gateway. The gateway functionality may not longer be accessed after\n  * this method is called.\n  * @returns {void}\n  */\n  close() {\n    this.connector.close();\n    this._removeGWCache(this);\n  }\n\n}\n\nconst DEFAULT_TIMEOUT = 10000; // Default timeout for non-owned AgentIDs\n\n\n/**\n* An identifier for an agent or a topic. This can be to send, receive messages, and set or get parameters\n* on an agent or topic on the fjåge master container.\n*\n* @class\n* @param {string} name - name of the agent\n* @param {boolean} [topic=false] - name of topic\n* @param {Gateway} [owner] - Gateway owner for this AgentID\n*/\nclass AgentID {\n\n  constructor(name, topic=false, owner) {\n    this.name = name;\n    this.topic = topic;\n    this.owner = owner;\n    this._timeout = owner ? owner._timeout : DEFAULT_TIMEOUT; // Default timeout if owner is not provided\n  }\n\n  /**\n  * Gets the name of the agent or topic.\n  *\n  * @returns {string} - name of agent or topic\n  */\n  getName() {\n    return this.name;\n  }\n\n  /**\n  * Returns true if the agent id represents a topic.\n  *\n  * @returns {boolean} - true if the agent id represents a topic, false if it represents an agent\n  */\n  isTopic() {\n    return this.topic;\n  }\n\n  /**\n  * Sends a message to the agent represented by this id.\n  *\n  * @param {Message} msg - message to send\n  * @returns {void}\n  */\n  send(msg) {\n    msg.recipient = this;\n    if (this.owner) this.owner.send(msg);\n    else throw new Error('Unowned AgentID cannot send messages');\n  }\n\n  /**\n  * Sends a request to the agent represented by this id and waits for a reponse.\n  *\n  * @param {Message} msg - request to send\n  * @param {number} [timeout=owner.timeout] - timeout in milliseconds\n  * @returns {Promise<Message>} - response\n  */\n  async request(msg, timeout=this._timeout) {\n    msg.recipient = this;\n    if (this.owner) return this.owner.request(msg, timeout);\n    else throw new Error('Unowned AgentID cannot send messages');\n  }\n\n  /**\n  * Gets a string representation of the agent id.\n  *\n  * @returns {string} - string representation of the agent id\n  */\n  toString() {\n    return this.toJSON() + ((this.owner && this.owner.connector) ? ` on ${this.owner.connector.url}` : '');\n  }\n\n  /**\n  * Gets a JSON string representation of the agent id.\n  *\n  * @returns {string} - JSON string representation of the agent id\n  */\n  toJSON() {\n    return (this.topic ? '#' : '') + this.name;\n  }\n\n  /**\n   * Inflate the AgentID from a JSON string or object.\n   *\n   * @param {string} json - JSON string or object to be converted to an AgentID\n   * @param {Gateway} [owner] - Gateway owner for this AgentID\n   * @returns {AgentID} - AgentID created from the JSON string or object\n   */\n  static fromJSON(json, owner) {\n    if (typeof json !== 'string') {\n      throw new Error('Invalid JSON for AgentID');\n    }\n    json = json.trim();\n    if (json.startsWith('#')) {\n      return new AgentID(json.substring(1), true, owner);\n    } else {\n      return new AgentID(json, false, owner);\n    }\n  }\n\n  /**\n  * Sets parameter(s) on the Agent referred to by this AgentID.\n  *\n  * @param {(string|string[])} params - parameters name(s) to be set\n  * @param {(Object|Object[])} values - parameters value(s) to be set\n  * @param {number} [index=-1] - index of parameter(s) to be set\n  * @param {number} [timeout=owner.timeout] - timeout for the response\n  * @returns {Promise<(Object|Object[])>} - a promise which returns the new value(s) of the parameters\n  */\n  async set (params, values, index=-1, timeout=this._timeout) {\n    if (!params) return null;\n    let msg = new ParameterReq();\n    msg.recipient = this;\n    if (Array.isArray(params)){\n      if (params.length != values.length) throw new Error(`Parameters and values arrays must have the same length: ${params.length} != ${values.length}`);\n      const clonedParams = params.slice(); // Clone the array to avoid side effects\n      const clonedValues = values.slice(); // Clone the values array\n      msg.param = clonedParams.shift();\n      msg.value = clonedValues.shift();\n      msg.requests = clonedParams.map((p, i) => {\n        return {\n          'param': p,\n          'value': clonedValues[i]\n        };\n      });\n    } else {\n      msg.param = params;\n      msg.value = values;\n    }\n    msg.index = Number.isInteger(index) ? index : -1;\n    const rsp = await this.owner.request(msg, timeout);\n    var ret = Array.isArray(params) ? new Array(params.length).fill(null) : null;\n    if (!rsp || rsp.perf != Performative.INFORM || !rsp.param) {\n      if (this.owner._returnNullOnFailedResponse) return ret;\n      else throw new Error(`Unable to set ${this.name}.${params} to ${values}`);\n    }\n    if (Array.isArray(params)) {\n      if (!rsp.values) rsp.values = {};\n      if (rsp.param) rsp.values[rsp.param] = rsp.value;\n      const rkeys = Object.keys(rsp.values);\n      return params.map( p => {\n        if (p.includes('.')) p = p.split('.').pop();\n        let f = rkeys.find(k => (k.includes('.') ? k.split('.').pop() : k) == p);\n        return f ? rsp.values[f] : undefined;\n      });\n    } else {\n      return rsp.value;\n    }\n  }\n\n\n  /**\n  * Gets parameter(s) on the Agent referred to by this AgentID.\n  *\n  * @param {(string|string[])} params - parameters name(s) to be get, null implies get value of all parameters on the Agent\n  * @param {number} [index=-1] - index of parameter(s) to be get\n  * @param {number} [timeout=owner.timeout] - timeout for the response\n  * @returns {Promise<(Object|Object[])>} - a promise which returns the value(s) of the parameters\n  */\n  async get(params, index=-1, timeout=this._timeout) {\n    let msg = new ParameterReq();\n    msg.recipient = this;\n    if (params){\n      if (Array.isArray(params)) {\n        const clonedParams = params.slice(); // Clone the array to avoid side effects\n        msg.param = clonedParams.shift();\n        msg.requests = clonedParams.map(p => {return {'param': p};});\n      }\n      else msg.param = params;\n    }\n    msg.index = Number.isInteger(index) ? index : -1;\n    const rsp = await this.owner.request(msg, timeout);\n    var ret = Array.isArray(params) ? new Array(params.length).fill(null) : null;\n    if (!rsp || rsp.perf != Performative.INFORM || !rsp.param) {\n      if (this.owner._returnNullOnFailedResponse) return ret;\n      else throw new Error(`Unable to get ${this.name}.${params}`);\n    }\n    // Request for listing of all parameters.\n    if (!params) {\n      if (!rsp.values) rsp.values = {};\n      if (rsp.param) rsp.values[rsp.param] = rsp.value;\n      return rsp.values;\n    } else if (Array.isArray(params)) {\n      if (!rsp.values) rsp.values = {};\n      if (rsp.param) rsp.values[rsp.param] = rsp.value;\n      const rkeys = Object.keys(rsp.values);\n      return params.map( p => {\n        if (p.includes('.')) p = p.split('.').pop();\n        let f = rkeys.find(k => (k.includes('.') ? k.split('.').pop() : k) == p);\n        return f ? rsp.values[f] : undefined;\n      });\n    } else {\n      return rsp.value;\n    }\n  }\n}\n\n/**\n* Base class for messages transmitted by one agent to another. Creates an empty message.\n* @class\n*\n* @property {string} msgID - unique message ID\n* @property {Performative} perf - performative of the message\n* @property {AgentID} [sender] - AgentID of the sender of the message\n* @property {AgentID} [recipient] - AgentID of the recipient of the message\n* @property {string} [inReplyTo] - ID of the message to which this message is a response\n* @property {number} [sentAt] - timestamp when the message was sent\n*/\nclass Message {\n\n  /**\n  * @param {Message} [inReplyToMsg] - message to which this message is a response\n  * @param {Performative} [perf=Performative.INFORM] - performative of the message\n  */\n  constructor(inReplyToMsg, perf=Performative.INFORM) {\n    this.__clazz__ = 'org.arl.fjage.Message';\n    this.msgID = UUID7.generate().toString();\n    this.perf = perf;\n    this.sender = null;\n    this.recipient = inReplyToMsg ? inReplyToMsg.sender : null;\n    this.inReplyTo = inReplyToMsg ? inReplyToMsg.msgID : null;\n  }\n\n  /**\n  * Gets a string representation of the message.\n  *\n  * @returns {string} - string representation\n  */\n  toString() {\n    let p = this.perf ? this.perf.toString() : 'MESSAGE';\n    if (this.__clazz__ == 'org.arl.fjage.Message') return p;\n    return p + ': ' + this.__clazz__.replace(/^.*\\./, '');\n  }\n\n  /** Convert a message into a object for JSON serialization.\n  *\n  * NOTE: we don't do any base64 encoding for TX as\n  *       we don't know what data type is intended\n  *\n  * @return {Object} - JSON string representation of the message\n  */\n  toJSON() {\n    let props = {};\n    for (let key in this) {\n      if (key.startsWith('_')) continue; // skip private properties\n      // @ts-ignore\n      props[key] = this[key];\n    }\n    return { 'clazz': this.__clazz__, 'data': props };\n  }\n\n\n  /**\n  * Create a message from a object parsed from the JSON representation of the message.\n  *\n  * @param {Object} jsonObj - Object containing all the properties of the message\n  * @returns {Message} - A message created from the Object\n  *\n  */\n  static fromJSON(jsonObj) {\n    if (!( 'clazz' in jsonObj) || !( 'data' in jsonObj)) {\n      throw new Error(`Invalid Object for Message : ${jsonObj}`);\n    }\n    let qclazz = jsonObj.clazz;\n    let clazz = qclazz.replace(/^.*\\./, '');\n    let rv = MessageClass[clazz] ? new MessageClass[clazz] : new Message();\n    rv.__clazz__ = qclazz;\n    // copy all properties from the data object\n    for (var key in jsonObj.data){\n      if (key === 'sender' || key === 'recipient') {\n        if (jsonObj.data[key] && typeof jsonObj.data[key] === 'string') {\n          rv[key] = AgentID.fromJSON(jsonObj.data[key]);\n        }\n      } else rv[key] = jsonObj.data[key];\n    }\n    return rv;\n  }\n}\n\n/**\n* A message class that can convey generic messages represented by key-value pairs.\n* @class\n* @extends Message\n*/\nclass GenericMessage extends Message {\n  /**\n  * Creates an empty generic message.\n  */\n  constructor() {\n    super();\n    this.__clazz__ = 'org.arl.fjage.GenericMessage';\n  }\n}\n\n/**\n* Creates a unqualified message class based on a fully qualified name.\n* @param {string} name - fully qualified name of the message class to be created\n* @param {typeof Message} [parent] - class of the parent MessageClass to inherit from\n* @constructs Message\n* @example\n* const ParameterReq = MessageClass('org.arl.fjage.param.ParameterReq');\n* let pReq = new ParameterReq()\n*/\nfunction MessageClass(name, parent=Message) {\n  let sname = name.replace(/^.*\\./, '');\n  if (MessageClass[sname]) return MessageClass[sname];\n  let cls = class extends parent {\n    /**\n    * @param {{ [x: string]: any; }} params\n    */\n    constructor(params) {\n      super();\n      this.__clazz__ = name;\n      if (params){\n        const keys = Object.keys(params);\n        for (let k of keys) {\n          this[k] = params[k];\n        }\n      }\n      if (name.endsWith('Req')) this.perf = Performative.REQUEST;\n    }\n  };\n  cls.__clazz__ = name;\n  MessageClass[sname] = cls;\n  return cls;\n}\n\n/**\n* @typedef {Object} ParameterReq.Entry\n* @property {string} param - parameter name\n* @property {Object} value - parameter value\n* @exports ParameterReq.Entry\n*/\n\n/**\n* A message that requests one or more parameters of an agent.\n*\n* @example <caption>Setting a parameter myAgent.x to 42</caption>\n* let req = new ParameterReq({\n*  recipient: myAgentId,\n*  param: 'x',\n*  value: 42\n* });\n*\n* @example <caption>Getting the value of myAgent.x</caption>\n* let req = new ParameterReq({\n* recipient: myAgentId,\n* param: 'x'\n* });\n*\n* @typedef {Message} ParameterReq\n* @property {string} param - parameters name to be get/set if only a single parameter is to be get/set\n* @property {Object} value - parameters value to be set if only a single parameter is to be set\n* @property {Array<ParameterReq.Entry>} requests - a list of multiple parameters to be get/set\n* @property {number} [index=-1] - index of parameter(s) to be set*\n* @exports ParameterReq\n*/\nconst ParameterReq = MessageClass('org.arl.fjage.param.ParameterReq');\n\n/**\n* A message that is a response to a {@link ParameterReq} message.\n*\n* @example <caption>Receiving a parameter from myAgent</caption>\n* let rsp = gw.receive(ParameterRsp)\n* rsp.sender // = myAgentId; sender of the message\n* rsp.param  // = 'x'; parameter name that was get/set\n* rsp.value  // = 42;  value of the parameter that was set\n* rsp.readonly // = [false]; indicates if the parameter is read-only\n*\n*\n* @typedef {Message} ParameterRsp\n* @property {string} param - parameters name if only a single parameter value was requested\n* @property {Object} value - parameters value if only a single parameter was requested\n* @property {Map<string, Object>} values - a map of multiple parameter names and their values if multiple parameters were requested\n* @property {Array<boolean>} readonly - a list of booleans indicating if the parameters are read-only\n* @property {number} [index=-1] - index of parameter(s) being returned\n* @exports ParameterReq\n*/\nconst ParameterRsp = MessageClass('org.arl.fjage.param.ParameterRsp');\n\n/**\n* Services supported by fjage agents.\n*/\nconst Services = {\n  SHELL : 'org.arl.fjage.shell.Services.SHELL'\n};\n\ninit();\n\nexport { AgentID, Gateway, GenericMessage, JSONMessage, Message, MessageClass, ParameterReq, ParameterRsp, Performative, Services };\n","import {AgentID, MessageClass, Services, Gateway} from 'fjage';\n\nconst DatagramReq = MessageClass('org.arl.unet.DatagramReq');\nconst DatagramNtf = MessageClass('org.arl.unet.DatagramNtf');\nconst TxFrameReq = MessageClass('org.arl.unet.phy.TxFrameReq', DatagramReq);\nconst RxFrameNtf = MessageClass('org.arl.unet.phy.RxFrameNtf', DatagramNtf);\nconst BasebandSignal = MessageClass('org.arl.unet.bb.BasebandSignal');\n\nlet UnetServices = {\n  'NODE_INFO': 'org.arl.unet.Services.NODE_INFO',\n  'ADDRESS_RESOLUTION': 'org.arl.unet.Services.ADDRESS_RESOLUTION',\n  'DATAGRAM': 'org.arl.unet.Services.DATAGRAM',\n  'PHYSICAL': 'org.arl.unet.Services.PHYSICAL',\n  'RANGING': 'org.arl.unet.Services.RANGING',\n  'BASEBAND': 'org.arl.unet.Services.BASEBAND',\n  'LINK': 'org.arl.unet.Services.LINK',\n  'MAC': 'org.arl.unet.Services.MAC',\n  'ROUTING': 'org.arl.unet.Services.ROUTING',\n  'ROUTE_MAINTENANCE': 'org.arl.unet.Services.ROUTE_MAINTENANCE',\n  'TRANSPORT': 'org.arl.unet.Services.TRANSPORT',\n  'REMOTE': 'org.arl.unet.Services.REMOTE',\n  'STATE_MANAGER': 'org.arl.unet.Services.STATE_MANAGER',\n  'DEVICE_INFO': 'org.arl.unet.Services.DEVICE_INFO',\n  'DOA': 'org.arl.unet.Services.DOA',\n  'SCHEDULER':'org.arl.unet.Services.SCHEDULER'\n};\n\nObject.assign(Services, UnetServices);\n\n/**\n * Well-known protocol number assignments used in UnetStack\n * @typedef {Object.<string, number>} Protocol\n */\nlet Protocol = {\n  'DATA' : 0,               // Protocol number for user application data.\n  'RANGING' : 1,            // Protocol number for use by ranging agents.\n  'LINK' : 2,               // Protocol number for use by link agents.\n  'REMOTE' : 3,             // Protocol number for use by remote management agents.\n  'MAC' : 4,                // Protocol number for use by MAC protocol agents.\n  'ROUTING' : 5,            // Protocol number for use by routing agents.\n  'TRANSPORT' : 6,          // Protocol number for use by transport agents.\n  'ROUTE_MAINTENANCE' : 7,   // Protocol number for use by route maintenance agents.\n  'LINK2' : 8,              // Protocol number for use by secondary link agents.\n  'USER' : 32,              // Lowest protocol number allowable for user protocols.\n  'MAX' : 63,               // Largest protocol number allowable.\n};\n\n/**\n * Well-known protocol Messages used in UnetStack\n * @typedef {Object.<string, MessageClass>} UnetMessages\n */\nlet UnetMessages = {\n  // unet\n  'TestReportNtf'          : MessageClass('org.arl.unet.TestReportNtf'),\n  'AbnormalTerminationNtf' : MessageClass('org.arl.unet.AbnormalTerminationNtf'),\n  'CapabilityListRsp'      : MessageClass('org.arl.unet.CapabilityListRsp'),\n  'CapabilityReq'          : MessageClass('org.arl.unet.CapabilityReq'),\n  'ClearReq'               : MessageClass('org.arl.unet.ClearReq'),\n  'DatagramCancelReq'      : MessageClass('org.arl.unet.DatagramCancelReq'),\n  'DatagramDeliveryNtf'    : MessageClass('org.arl.unet.DatagramDeliveryNtf'),\n  'DatagramFailureNtf'     : MessageClass('org.arl.unet.DatagramFailureNtf'),\n  'DatagramNtf'            : MessageClass('org.arl.unet.DatagramNtf'),\n  'DatagramProgressNtf'    : MessageClass('org.arl.unet.DatagramProgressNtf'),\n  'DatagramReq'            : MessageClass('org.arl.unet.DatagramReq'),\n  'ParamChangeNtf'         : MessageClass('org.arl.unet.ParamChangeNtf'),\n  'RefuseRsp'              : MessageClass('org.arl.unet.RefuseRsp'),\n  'FailureNtf'             : MessageClass('org.arl.unet.FailureNtf'),\n\n  // net\n  'DatagramTraceReq'       : MessageClass('org.arl.unet.net.DatagramTraceReq'),\n  'RouteDiscoveryReq'      : MessageClass('org.arl.unet.net.RouteDiscoveryReq'),\n  'RouteTraceReq'          : MessageClass('org.arl.unet.net.RouteTraceReq'),\n  'RouteDiscoveryNtf'      : MessageClass('org.arl.unet.net.RouteDiscoveryNtf'),\n  'RouteTraceNtf'          : MessageClass('org.arl.unet.net.RouteTraceNtf'),\n\n  // phy\n  'FecDecodeReq'           : MessageClass('org.arl.unet.phy.FecDecodeReq'),\n  'RxSWiG1FrameNtf'        : MessageClass('org.arl.unet.phy.RxSWiG1FrameNtf', RxFrameNtf),\n  'TxSWiG1FrameReq'        : MessageClass('org.arl.unet.phy.TxSWiG1FrameReq', TxFrameReq),\n  'RxJanusFrameNtf'        : MessageClass('org.arl.unet.phy.RxJanusFrameNtf', RxFrameNtf),\n  'TxJanusFrameReq'        : MessageClass('org.arl.unet.phy.TxJanusFrameReq', TxFrameReq),\n  'BadFrameNtf'            : MessageClass('org.arl.unet.phy.BadFrameNtf'),\n  'BadRangeNtf'            : MessageClass('org.arl.unet.phy.BadRangeNtf'),\n  'ClearSyncReq'           : MessageClass('org.arl.unet.phy.ClearSyncReq'),\n  'CollisionNtf'           : MessageClass('org.arl.unet.phy.CollisionNtf'),\n  'RxFrameNtf'             : MessageClass('org.arl.unet.phy.RxFrameNtf', DatagramNtf),\n  'RxFrameStartNtf'        : MessageClass('org.arl.unet.phy.RxFrameStartNtf'),\n  'SyncInfoReq'            : MessageClass('org.arl.unet.phy.SyncInfoReq'),\n  'SyncInfoRsp'            : MessageClass('org.arl.unet.phy.SyncInfoRsp'),\n  'TxFrameNtf'             : MessageClass('org.arl.unet.phy.TxFrameNtf'),\n  'TxFrameReq'             : MessageClass('org.arl.unet.phy.TxFrameReq', DatagramReq),\n  'TxFrameStartNtf'        : MessageClass('org.arl.unet.phy.TxFrameStartNtf'),\n  'TxRawFrameReq'          : MessageClass('org.arl.unet.phy.TxRawFrameReq'),\n\n  // addr\n  'AddressAllocReq'        : MessageClass('org.arl.unet.addr.AddressAllocReq'),\n  'AddressAllocRsp'        : MessageClass('org.arl.unet.addr.AddressAllocRsp'),\n  'AddressResolutionReq'   : MessageClass('org.arl.unet.addr.AddressResolutionReq'),\n  'AddressResolutionRsp'   : MessageClass('org.arl.unet.addr.AddressResolutionRsp'),\n\n  // bb\n  'BasebandSignal'         : MessageClass('org.arl.unet.bb.BasebandSignal'),\n  'RecordBasebandSignalReq' : MessageClass('org.arl.unet.bb.RecordBasebandSignalReq'),\n  'RxBasebandSignalNtf'    : MessageClass('org.arl.unet.bb.RxBasebandSignalNtf', BasebandSignal),\n  'TxBasebandSignalReq'    : MessageClass('org.arl.unet.bb.TxBasebandSignalReq', BasebandSignal),\n\n  // link\n  'LinkStatusNtf'          : MessageClass('org.arl.unet.link.LinkStatusNtf'),\n\n  // localization\n  'RangeNtf'               : MessageClass('org.arl.unet.localization.RangeNtf'),\n  'RangeReq'               : MessageClass('org.arl.unet.localization.RangeReq'),\n  'BeaconReq'              : MessageClass('org.arl.unet.localization.BeaconReq'),\n  'RespondReq'             : MessageClass('org.arl.unet.localization.RespondReq'),\n  'InterrogationNtf'       : MessageClass('org.arl.unet.localization.InterrogationNtf'),\n\n\n  // mac\n  'ReservationAcceptReq'   : MessageClass('org.arl.unet.mac.ReservationAcceptReq'),\n  'ReservationCancelReq'   : MessageClass('org.arl.unet.mac.ReservationCancelReq'),\n  'ReservationReq'         : MessageClass('org.arl.unet.mac.ReservationReq'),\n  'ReservationRsp'         : MessageClass('org.arl.unet.mac.ReservationRsp'),\n  'ReservationStatusNtf'   : MessageClass('org.arl.unet.mac.ReservationStatusNtf'),\n  'RxAckNtf'               : MessageClass('org.arl.unet.mac.RxAckNtf'),\n  'TxAckReq'               : MessageClass('org.arl.unet.mac.TxAckReq'),\n\n\n  // remote\n  'RemoteExecReq'          : MessageClass('org.arl.unet.remote.RemoteExecReq'),\n  'RemoteFailureNtf'       : MessageClass('org.arl.unet.remote.RemoteFailureNtf'),\n  'RemoteFileGetReq'       : MessageClass('org.arl.unet.remote.RemoteFileGetReq'),\n  'RemoteFileNtf'          : MessageClass('org.arl.unet.remote.RemoteFileNtf'),\n  'RemoteFilePutReq'       : MessageClass('org.arl.unet.remote.RemoteFilePutReq'),\n  'RemoteSuccessNtf'       : MessageClass('org.arl.unet.remote.RemoteSuccessNtf'),\n  'RemoteTextNtf'          : MessageClass('org.arl.unet.remote.RemoteTextNtf'),\n  'RemoteTextReq'          : MessageClass('org.arl.unet.remote.RemoteTextReq'),\n\n  // scheduler\n  'AddScheduledSleepReq'   : MessageClass('org.arl.unet.scheduler.AddScheduledSleepReq'),\n  'GetSleepScheduleReq'    : MessageClass('org.arl.unet.scheduler.GetSleepScheduleReq'),\n  'RemoveScheduledSleepReq' : MessageClass('org.arl.unet.scheduler.RemoveScheduledSleepReq'),\n  'SleepScheduleRsp'       : MessageClass('org.arl.unet.scheduler.SleepScheduleRsp'),\n  'WakeFromSleepNtf'       : MessageClass('org.arl.unet.scheduler.WakeFromSleepNtf'),\n\n  // state\n  'ClearStateReq'          : MessageClass('org.arl.unet.state.ClearStateReq'),\n  'SaveStateReq'           : MessageClass('org.arl.unet.state.SaveStateReq')\n};\n\n/**\n  * Convert coordinates from a local coordinates to GPS coordinate\n  * @param {Array} origin - Local coordinate system's origin as `[latitude, longitude]`\n  * @param {Number} x - X coordinate of the local coordinate to be converted\n  * @param {Number} y - Y coordinate of the local coordinate to be converted\n  * @returns {Array} - GPS coordinates (in decimal degrees) as `[latitude, longitude]`\n  */\n\nexport function toGps(origin, x, y) {\n  let coords = [] ;\n  let [xScale,yScale] = _initConv(origin[0]);\n  coords[1] = x/xScale + origin[1];\n  coords[0] = y/yScale + origin[0];\n  return coords;\n}\n\n/**\n  * Convert coordinates from a GPS coordinates to local coordinate\n  * @param {Array} origin - Local coordinate system's origin as `[latitude, longitude]`\n  * @param {Number} lat - Latitude of the GPS coordinate to be converted\n  * @param {Number} lon - Longitude of the GPS coordinate to be converted\n  * @returns {Array} - GPS coordinates (in decimal degrees) as `[latitude, longitude]`\n  */\nexport function toLocal(origin, lat, lon) {\n  let pos = [];\n  let [xScale,yScale] = _initConv(origin[0]);\n  pos[0] = (lon-origin[1]) * xScale;\n  pos[1] = (lat-origin[0]) * yScale;\n  return pos;\n}\n\nfunction _initConv(lat){\n  let rlat = lat * Math.PI/180;\n  let yScale = 111132.92 - 559.82*Math.cos(2*rlat) + 1.175*Math.cos(4*rlat) - 0.0023*Math.cos(6*rlat);\n  let xScale = 111412.84*Math.cos(rlat) - 93.5*Math.cos(3*rlat) + 0.118*Math.cos(5*rlat);\n  return [xScale, yScale];\n}\n\n/**\n * A message which requests the transmission of the datagram from the Unet\n *\n * @typedef {Message} DatagramReq\n * @property {number[]} data - data as an Array of bytes\n * @property {number} from - from/source node address\n * @property {number} to - to/destination node address\n * @property {number} protocol - protocol number to be used to send this Datagram\n * @property {boolean} reliability - true if Datagram should be reliable, false if unreliable\n * @property {number} ttl - time-to-live for the datagram. Time-to-live is advisory, and an agent may choose it ignore it\n */\n\n/**\n * Notification of received datagram message received by the Unet node.\n *\n * @typedef {Message} DatagramNtf\n * @property {number[]} data - data as an Array of bytes\n * @property {number} from - from/source node address\n * @property {number} to - to/destination node address\n * @property {number} protocol - protocol number to be used to send this Datagram\n * @property {number} ttl - time-to-live for the datagram. Time-to-live is advisory, and an agent may choose it ignore it\n */\n\n/**\n * An identifier for an agent or a topic.\n * @external AgentID\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n * Services supported by fjage agents.\n * @external Services\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n *  An action represented by a message.\n * @external Performative\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n * Function to creates a unqualified message class based on a fully qualified name.\n * @external MessageClass\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n * A caching CachingAgentID which caches Agent parameters locally.\n *\n * @class\n * @extends AgentID\n * @param {string | AgentID} name - name of the agent or an AgentID to copy\n * @param {boolean} topic - name of topic\n * @param {Gateway} owner - Gateway owner for this AgentID\n * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n *\n*/\nclass CachingAgentID extends AgentID {\n\n  constructor(name, topic, owner, greedy=true) {\n    if (name instanceof AgentID) {\n      super(name.getName(), name.topic, name.owner);\n    } else {\n      super(name, topic, owner);\n    }\n    this.greedy = greedy;\n    this.cache = {};\n    this.specialParams = ['name', 'version'];\n  }\n\n  /**\n   * Sets parameter(s) on the Agent referred to by this AgentID, and caches the parameter(s).\n   *\n   * @param {(string|string[])} params - parameters name(s) to be set\n   * @param {(Object|Object[])} values - parameters value(s) to be set\n   * @param {number} [index=-1] - index of parameter(s) to be set\n   * @param {number} [timeout=5000] - timeout for the response\n   * @returns {Promise<(Object|Object[])>} - a promise which returns the new value(s) of the parameters\n   */\n  async set(params, values, index=-1, timeout=5000) {\n    let s = await super.set(params, values, index, timeout);\n    this._updateCache(params, s, index);\n    return s;\n  }\n\n  /**\n   * Gets parameter(s) on the Agent referred to by this AgentID, getting them from the cache if possible.\n   *\n   * @param {(string|string[])} params - parameters name(s) to be fetched\n   * @param {number} [index=-1] - index of parameter(s) to be fetched\n   * @param {number} [timeout=5000] - timeout for the response\n   * @param {number} [maxage=5000] - maximum age of the cached result to retreive\n   * @returns {Promise<(Object|Object[])>} - a promise which returns the value(s) of the parameters\n   */\n  async get(params, index=-1, timeout=5000, maxage=5000) {\n    if (this._isCached(params, index, maxage)) return this._getCache(params, index);\n    if (this.greedy &&\n      !(Array.isArray(params) && [...new Set([...params, ...this.specialParams])].length!=0) &&\n      !this.specialParams.includes(params)) {\n      let rsp = await super.get(null, index, timeout);\n      this._updateCache(null, rsp, index);\n      if (!rsp) return Array.isArray(params) ? new Array(params.length).fill(null) : null;\n      if (!params) return rsp;\n      else if (Array.isArray(params)) {\n        return params.map(p => {\n          let f = Object.keys(rsp).find(rv => this._toNamed(rv) === p);\n          return f ? rsp[f] : null;\n        });\n      } else {\n        let f = Object.keys(rsp).find(rv => this._toNamed(rv) === params);\n        return f ? rsp[f] : null;\n      }\n    } else{\n      let r = await super.get(params, index, timeout);\n      this._updateCache(params, r, index);\n      return r;\n    }\n  }\n\n  _updateCache(params, vals, index) {\n    if (vals == null || Array.isArray(vals) && vals.every(v => v == null)) return;\n    if (params == null) {\n      params = Object.keys(vals);\n      vals = Object.values(vals);\n    } else if (!Array.isArray(params)) params = [params];\n    if (!Array.isArray(vals)) vals = [vals];\n    params = params.map(this._toNamed);\n    if (this.cache[index.toString()] === undefined) this.cache[index.toString()] = {};\n    let c = this.cache[index.toString()];\n    for (let i = 0; i < params.length; i++) {\n      if (c[params[i]] === undefined) c[params[i]] = {};\n      c[params[i]].value = vals[i];\n      c[params[i]].ctime = Date.now();\n    }\n  }\n\n  _isCached(params, index, maxage) {\n    if (maxage <= 0) return false;\n    if (params == null) return false;\n    let c = this.cache[index.toString()];\n    if (!c) {\n      return false;\n    }\n    if (!Array.isArray(params)) params = [params];\n    const rv = params.every(p => {\n      p = this._toNamed(p);\n      return (p in c) && (Date.now() - c[p].ctime <= maxage);\n    });\n    return rv;\n  }\n\n  _getCache(params, index) {\n    let c = this.cache[index.toString()];\n    if (!c) return null;\n    if (!Array.isArray(params)){\n      if (params in c) return c[params].value;\n      return null;\n    }else {\n      return params.map(p => p in c ? c[p].value : null);\n    }\n  }\n\n  _toNamed(param) {\n    const idx = param.lastIndexOf('.');\n    if (idx < 0) return param;\n    else return param.slice(idx+1);\n  }\n\n}\n\n\nclass CachingGateway extends Gateway{\n\n  /**\n   * Get an AgentID for a given agent name.\n   *\n   * @param {string} name - name of agent\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {AgentID|CachingAgentID} - AgentID for the given name\n   */\n  agent(name, caching=true, greedy=true) {\n    const aid = super.agent(name);\n    return caching ? new CachingAgentID(aid, null, null, greedy) : aid;\n  }\n\n  /**\n   * Returns an object representing the named topic.\n   *\n   * @param {string|AgentID} topic - name of the topic or AgentID\n   * @param {string} topic2 - name of the topic if the topic param is an AgentID\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {AgentID|CachingAgentID} - object representing the topic\n   */\n  topic(topic, topic2, caching=true, greedy=true) {\n    const aid = super.topic(topic, topic2);\n    return caching ? new CachingAgentID(aid, null, null, greedy) : aid;\n  }\n\n  /**\n   * Finds an agent that provides a named service. If multiple agents are registered\n   * to provide a given service, any of the agents' id may be returned.\n   *\n   * @param {string} service - the named service of interest\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {Promise<?AgentID|CachingAgentID>} - a promise which returns an agent id for an agent that provides the service when resolved\n   */\n  async agentForService(service, caching=true, greedy=true) {\n    const aid = await super.agentForService(service);\n    if (!aid) return aid;\n    return caching ? new CachingAgentID(aid, null, null, greedy) : aid;\n  }\n\n  /**\n   * Finds all agents that provides a named service.\n   *\n   * @param {string} service - the named service of interest\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {Promise<?AgentID|CachingAgentID[]>} - a promise which returns an array of all agent ids that provides the service when resolved\n   */\n  async agentsForService(service, caching=true, greedy=true) {\n    const aids = await super.agentsForService(service);\n    return caching ? aids.map(a => new CachingAgentID(a, null, null, greedy)) : aids;\n  }\n}\n\nexport {AgentID, Services, UnetMessages, Protocol, CachingGateway, CachingAgentID};\n","import {Gateway, Performative} from 'fjage';\nimport {Services, UnetMessages, Protocol} from './unetutils';\n\nconst REQUEST_TIMEOUT = 1000;\n\nconst AddressResolutionReq = UnetMessages.AddressResolutionReq;\nconst DatagramReq = UnetMessages.DatagramReq;\nconst DatagramNtf = UnetMessages.DatagramNtf;\nconst RxFrameNtf = UnetMessages.RxFrameNtf;\n\n/**\n * Creates a new UnetSocket to connect to a running Unet instance. This constructor returns a\n * {@link Promise} instead of the constructed UnetSocket object. Use `await` or `.then()` to get\n * a reference to the UnetSocket object. Based on if this is run in a Browser or Node.js,\n * it will internally connect over WebSockets or TCP respectively.\n *\n *\n * @class UnetSocket\n * @param {string} [hostname] - hostname/ip address of the master container to connect to\n * @param {string} [port] - port number of the master container to connect to\n * @param {string} [path='']  - path of the master container to connect to (for WebSockets)\n * @returns {Promise<UnetSocket>} - Promise which resolves to the UnetSocket object being constructed\n *\n * @example\n * let socket = await new UnetSocket('localhost', 8081, '/ws/');\n */\nexport default class UnetSocket {\n\n  constructor(hostname, port, path='') {\n    return (async () => {\n      this.gw = new Gateway({\n        hostname : hostname,\n        port : port,\n        path : path\n      });\n      this.localProtocol = -1;\n      this.remoteAddress = -1;\n      this.remoteProtocol = Protocol.DATA;\n      this.timeout = 0;\n      this.provider = null;\n      const alist = await this.gw.agentsForService(Services.DATAGRAM);\n      alist.forEach(a => {this.gw.subscribe(this.gw.topic(a));});\n      return this;\n    })();\n  }\n\n  /**\n   * Closes the socket. The socket functionality may not longer be accessed after this method is called.\n   * @returns {void}\n   */\n  close() {\n    this.gw.close();\n    this.gw = null;\n  }\n\n  /**\n   * Checks if a socket is closed.\n   * @returns {boolean} - true if closed, false if open\n   */\n  isClosed() {\n    return this.gw == null;\n  }\n\n  /**\n   * Binds a socket to listen to a specific protocol datagrams.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are reserved protocols\n   * and cannot be bound. Unbound sockets listen to all unreserved\n   * @param {Protocol} protocol - protocol number to listen for\n   * @returns {boolean} - true on success, false on failure\n   */\n  bind(protocol) {\n    if (protocol == Protocol.DATA || (protocol >= Protocol.USER && protocol <= Protocol.MAX)) {\n      this.localProtocol = protocol;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Unbinds a socket so that it listens to all unreserved protocols.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are considered reserved.\n   * @returns {void}\n   */\n  unbind() { this.localProtocol = -1;}\n\n  /**\n   * Checks if a socket is bound.\n   * @returns {boolean} - true if bound to a protocol, false if unbound\n   */\n  isBound() { return this.localProtocol >= 0;}\n\n  /**\n   * Sets the default destination address and destination protocol number for datagrams sent\n   * using this socket. The defaults can be overridden for specific send() calls.\n   * The default protcol number when a socket is opened is Protcol.DATA.\n   * The default node address is undefined.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are considered reserved,\n   * and cannot be used for sending datagrams using the socket.\n   *\n   * @param {number} to - default destination node address\n   * @param {Protocol} protocol - default protocol number\n   * @returns {boolean} - true on success, false on failure\n   */\n  connect(to, protocol) {\n    if (to >= 0 && (protocol == Protocol.DATA || (protocol >= Protocol.USER && protocol <= Protocol.MAX))) {\n      this.remoteAddress = to;\n      this.remoteProtocol = protocol;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Resets the default destination address to undefined, and the default protocol number\n   * to Protocol.DATA.\n   * @returns {void}\n   */\n  disconnect() {\n    this.remoteAddress = -1;\n    this.remoteProtocol = 0;\n  }\n\n  /**\n   * Checks if a socket is connected, i.e., has a default destination address and protocol number.\n   * @returns {boolean} - true if connected, false otherwise\n   */\n  isConnected() { return this.remoteAddress >= 0; }\n\n  /**\n   * Gets the local node address of the Unet node connected to.\n   * @returns {Promise<int>} - local node address, or -1 on error\n   */\n  async getLocalAddress() {\n    if (this.gw == null) return -1;\n    const nodeinfo = await this.gw.agentForService(Services.NODE_INFO);\n    if (nodeinfo == null) return -1;\n    const addr = await nodeinfo.get('address');\n    return addr != null ? addr : -1;\n  }\n\n  /**\n   * Gets the protocol number that the socket is bound to.\n   * @returns {number}} - protocol number if socket is bound, -1 otherwise\n   */\n  getLocalProtocol() { return this.localProtocol; }\n\n  /**\n   * Gets the default destination node address for a connected socket.\n   * @returns {number}} - default destination node address if connected, -1 otherwise\n   */\n  getRemoteAddress() { return this.remoteAddress; }\n\n  /**\n   * Gets the default transmission protocol number.\n   * @returns {number}} - default protocol number used to transmit a datagram\n   */\n  getRemoteProtocol() { return this.remoteProtocol; }\n\n  /**\n   * Sets the timeout for datagram reception. A timeout of 0 means the\n   * {@link UnetSocket#receive|receive method} will check any appropriate\n   * Datagram has already been received (and is cached) else return immediately.\n   *\n   * @param {number} ms - timeout in milliseconds\n   * @returns {void}\n   */\n  setTimeout(ms) {\n    if (ms < 0) ms = 0;\n    this.timeout = ms;\n  }\n\n  /**\n   * Gets the timeout for datagram reception.\n   * @returns {number} - timeout in milliseconds\n   */\n  getTimeout() { return this.timeout; }\n\n  /**\n   * Transmits a datagram to the specified node address using the specified protocol.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are considered reserved,\n   * and cannot be used for sending datagrams using the socket.\n   * @param {number[]|DatagramReq} data - data to be sent over the socket as an Array of bytes or DatagramReq\n   * @param {number} to - destination node address\n   * @param {number} protocol - protocol number\n   * @returns {Promise<boolean>} - true if the Unet node agreed to send out the Datagram, false otherwise\n   */\n  async send(data, to=this.remoteAddress, protocol=this.remoteProtocol) {\n    if (to < 0 || this.gw == null) return false;\n    var req;\n    if (Array.isArray(data)){\n      req = new DatagramReq();\n      req.data = data;\n      req.to = to;\n      req.protocol = protocol;\n    } else if (data instanceof DatagramReq){\n      req = data;\n    } else {\n      return false;\n    }\n    let p = req.protocol;\n    if (p != Protocol.DATA && (p < Protocol.USER || p > Protocol.MAX)) return false;\n    if (req.recipient == null) {\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.TRANSPORT);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.ROUTING);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.LINK);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.PHYSICAL);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.DATAGRAM);\n      if (this.provider == null) return false;\n      req.recipient = this.provider;\n    }\n    const rsp = await this.gw.request(req, REQUEST_TIMEOUT);\n    return (rsp != null && rsp.perf == Performative.AGREE);\n  }\n\n  /**\n   * Receives a datagram sent to the local node and the bound protocol number. If the socket is unbound,\n   * then datagrams with all unreserved protocols are received. Any broadcast datagrams are also received.\n   *\n   * @returns {Promise<?DatagramNtf>} - datagram received by the socket\n   */\n  async receive() {\n    if (this.gw == null) return null;\n    return await this.gw.receive(msg => {\n      if (msg.__clazz__ != DatagramNtf.__clazz__ && msg.__clazz__ != RxFrameNtf.__clazz__ ) return false;\n      let p = msg.protocol;\n      if (p == Protocol.DATA || p >= Protocol.USER) {\n        return this.localProtocol < 0 || this.localProtocol == p;\n      }\n      return false;\n    }, this.timeout);\n  }\n\n  /**\n   * Gets a Gateway to provide low-level access to UnetStack.\n   * @returns {Gateway} - underlying fjage Gateway supporting this socket\n   */\n  getGateway() { return this.gw; }\n\n  /**\n   * Gets an AgentID providing a specified service for low-level access to UnetStack\n   * @param {string} svc - the named service of interest\n   * @returns {Promise<?AgentID>} - a promise which returns an {@link AgentID} that provides the service when resolved\n   */\n  async agentForService(svc) {\n    if (this.gw == null) return null;\n    return await this.gw.agentForService(svc);\n  }\n\n  /**\n   *\n   * @param {string} svc - the named service of interest\n   * @returns {Promise<AgentID[]>} - a promise which returns an array of {@link AgentID|AgentIDs} that provides the service when resolved\n   */\n  async agentsForService(svc) {\n    if (this.gw == null) return null;\n    return await this.gw.agentsForService(svc);\n  }\n\n  /**\n   * Gets a named AgentID for low-level access to UnetStack.\n   * @param {string} name - name of agent\n   * @returns {AgentID} - AgentID for the given name\n   */\n  agent(name) {\n    if (this.gw == null) return null;\n    return this.gw.agent(name);\n  }\n\n  /**\n   * Resolve node name to node address.\n   * @param {string} nodeName - name of the node to resolve\n   * @returns {Promise<?number>} - address of the node, or null if unable to resolve\n   */\n  async host(nodeName) {\n    const arp = await this.agentForService(Services.ADDRESS_RESOLUTION);\n    if (arp == null) return null;\n    const req = new AddressResolutionReq(nodeName);\n    req.name = nodeName;\n    req.recipient = arp;\n    const rsp = await this.gw.request(req, REQUEST_TIMEOUT);\n    if (rsp == null || ! Object.prototype.hasOwnProperty.call(rsp, 'address')) return null;\n    return rsp.address;\n  }\n}"],"names":["Performative","REQUEST","AGREE","REFUSE","FAILURE","INFORM","CONFIRM","DISCONFIRM","QUERY_IF","NOT_UNDERSTOOD","CFP","PROPOSE","CANCEL","UUID7","constructor","bytes","length","Error","this","generate","Uint8Array","randomBytes","crypto","getRandomValues","timestamp","Date","now","timestampHi","Math","floor","timestampLo","set","getTimestamp","toString","result","i","padStart","isBrowser","window","document","isNode","process","versions","node","isWebWorker","self","name","isJsDom","navigator","userAgent","includes","Deno","version","deno","bun","SOCKET_OPEN","SOCKET_OPENING","createConnection","TCPConnector","opts","host","hostname","port","_keepAlive","keepAlive","_reconnectTime","reconnectTime","url","URL","_buf","_firstConn","_firstReConn","pendingOnOpen","connListeners","debug","_sockInit","_sendConnEvent","val","forEach","l","call","_sockSetup","import","then","module","error","console","log","sock","setEncoding","on","_onSockOpen","bind","_sockReconnect","send","data","write","readyState","setTimeout","_processSockData","cb","s","lines","split","idx","_onSockRx","remoteAddress","remotePort","push","setReadCallback","addConnectionListener","listener","removeConnectionListener","ndx","indexOf","splice","close","removeAllListeners","destroy","WSConnector","pathname","_websockSetup","WebSocket","onerror","_websockReconnect","onopen","_onWebsockOpen","onclose","CONNECTING","OPEN","onmessage","event","_onWebsockRx","JSONMessage","jsonString","owner","id","action","inResponseTo","agentID","agentIDs","agentTypes","service","services","answer","message","relay","creds","auth","parsed","JSON","parse","_decodeBase64","Message","fromJSON","AgentID","map","Object","assign","e","createSend","msg","jsonMsg","Actions","SEND","createWantsMessagesFor","Array","isArray","WANTS_MESSAGES_FOR","createAgents","AGENTS","createContainsAgent","CONTAINS_AGENT","createAgentForService","AGENT_FOR_SERVICE","createAgentsForService","AGENTS_FOR_SERVICE","toJSON","jsonObj","stringify","_k","d","clazz","startsWith","base64","dtype","littleEndian","a","atob","Buffer","from","_atob","len","charCodeAt","rv","view","DataView","buffer","getUint8","getInt16","getInt32","getBigInt64","getFloat32","getFloat64","_b64toArray","GATEWAY_DEFAULTS","timeout","queueSize","returnNullOnFailedResponse","DEFAULT_URL","gObj","Gateway","key","undefined","existing","_getGWCache","_timeout","_queueSize","_returnNullOnFailedResponse","_cancelPendingOnDisconnect","cancelPendingOnDisconnect","_pending_actions","_subscriptions","_pending_receives","_eventListeners","_queue","connected","aid","random","substring","join","connector","_createConnector","_addGWCache","_sendEvent","type","warn","_sendReceivers","lid","_onMsgRx","recipient","shift","rsp","_msgTx","_msgTxRx","rq","Promise","resolve","timer","clearTimeout","conn","protocol","parseInt","state","flush","_update_watch","_isConstructor","value","Proxy","construct","err","_matchMessage","filter","String","inReplyTo","prototype","hasOwnProperty","msgID","__proto__","__clazz__","_getMessageFromQueue","matchedMsg","find","fjage","gateways","f","g","gw","_removeGWCache","index","watch","keys","addEventListener","removeEventListener","addMessageListener","removeMessageListener","addConnListener","removeConnListener","getAgentID","agent","topic","topic2","isTopic","getName","subscribe","unsubscribe","agents","containsAgent","agentForService","agentsForService","sender","request","receive","json","trim","params","values","ParameterReq","clonedParams","slice","clonedValues","param","requests","p","Number","isInteger","ret","fill","perf","rkeys","pop","k","get","inReplyToMsg","replace","props","qclazz","MessageClass","parent","sname","cls","super","endsWith","Services","SHELL","location","global","DatagramReq","DatagramNtf","TxFrameReq","RxFrameNtf","BasebandSignal","NODE_INFO","ADDRESS_RESOLUTION","DATAGRAM","PHYSICAL","RANGING","BASEBAND","LINK","MAC","ROUTING","ROUTE_MAINTENANCE","TRANSPORT","REMOTE","STATE_MANAGER","DEVICE_INFO","DOA","SCHEDULER","Protocol","DATA","LINK2","USER","MAX","UnetMessages","TestReportNtf","AbnormalTerminationNtf","CapabilityListRsp","CapabilityReq","ClearReq","DatagramCancelReq","DatagramDeliveryNtf","DatagramFailureNtf","DatagramProgressNtf","ParamChangeNtf","RefuseRsp","FailureNtf","DatagramTraceReq","RouteDiscoveryReq","RouteTraceReq","RouteDiscoveryNtf","RouteTraceNtf","FecDecodeReq","RxSWiG1FrameNtf","TxSWiG1FrameReq","RxJanusFrameNtf","TxJanusFrameReq","BadFrameNtf","BadRangeNtf","ClearSyncReq","CollisionNtf","RxFrameStartNtf","SyncInfoReq","SyncInfoRsp","TxFrameNtf","TxFrameStartNtf","TxRawFrameReq","AddressAllocReq","AddressAllocRsp","AddressResolutionReq","AddressResolutionRsp","RecordBasebandSignalReq","RxBasebandSignalNtf","TxBasebandSignalReq","LinkStatusNtf","RangeNtf","RangeReq","BeaconReq","RespondReq","InterrogationNtf","ReservationAcceptReq","ReservationCancelReq","ReservationReq","ReservationRsp","ReservationStatusNtf","RxAckNtf","TxAckReq","RemoteExecReq","RemoteFailureNtf","RemoteFileGetReq","RemoteFileNtf","RemoteFilePutReq","RemoteSuccessNtf","RemoteTextNtf","RemoteTextReq","AddScheduledSleepReq","GetSleepScheduleReq","RemoveScheduledSleepReq","SleepScheduleRsp","WakeFromSleepNtf","ClearStateReq","SaveStateReq","_initConv","lat","rlat","PI","yScale","cos","CachingAgentID","greedy","cache","specialParams","_updateCache","maxage","_isCached","_getCache","Set","r","_toNamed","vals","every","v","c","ctime","lastIndexOf","caching","aids","path","localProtocol","remoteProtocol","provider","isClosed","unbind","isBound","connect","to","disconnect","isConnected","getLocalAddress","nodeinfo","addr","getLocalProtocol","getRemoteAddress","getRemoteProtocol","ms","getTimeout","req","getGateway","svc","nodeName","arp","address","origin","x","y","coords","xScale","lon","pos"],"mappings":"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","x_google_ignoreList":[0]}