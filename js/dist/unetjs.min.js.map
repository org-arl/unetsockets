{"version":3,"file":"unetjs.min.js","sources":["../node_modules/fjage/dist/esm/fjage.js","../src/unetutils.js","../src/unetsocket.js"],"sourcesContent":["/* fjage.js v2.1.0 */\n\nconst isBrowser =\n  typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nconst isNode =\n  typeof process !== \"undefined\" &&\n  process.versions != null &&\n  process.versions.node != null;\n\nconst isWebWorker =\n  typeof self === \"object\" &&\n  self.constructor &&\n  self.constructor.name === \"DedicatedWorkerGlobalScope\";\n\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\nconst isJsDom =\n  (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n  (typeof navigator !== \"undefined\" &&\n    (navigator.userAgent.includes(\"Node.js\") ||\n      navigator.userAgent.includes(\"jsdom\")));\n\ntypeof Deno !== \"undefined\" && typeof Deno.core !== \"undefined\";\n\nconst SOCKET_OPEN = 'open';\nconst SOCKET_OPENING = 'opening';\nconst DEFAULT_RECONNECT_TIME$1 = 5000;       // ms, delay between retries to connect to the server.\n\nvar createConnection;\n\n/**\n * @class\n * @ignore\n */\nclass TCPConnector {\n\n  /**\n    * Create an TCPConnector to connect to a fjage master over TCP\n   * @param {Object} opts\n   * @param {string} [opts.hostname='localhost'] - hostname/ip address of the master container to connect to\n   * @param {number} [opts.port=1100] - port number of the master container to connect to\n   * @param {boolean} [opts.keepAlive=true] - try to reconnect if the connection is lost\n   * @param {boolean} [opts.debug=false] - debug info to be logged to console?\n   * @param {number} [opts.reconnectTime=5000] - time before reconnection is attempted after an error\n    */\n  constructor(opts = {}) {\n    let host = opts.hostname || 'localhost';\n    let port = opts.port || 1100;\n    this._keepAlive = opts.keepAlive;\n    this._reconnectTime = opts.reconnectTime || DEFAULT_RECONNECT_TIME$1;\n    this.url = new URL('tcp://localhost');\n    this.url.hostname = host;\n    this.url.port = port.toString();\n    this._buf = '';\n    this._firstConn = true;               // if the Gateway has managed to connect to a server before\n    this._firstReConn = true;             // if the Gateway has attempted to reconnect to a server before\n    this.pendingOnOpen = [];              // list of callbacks make as soon as gateway is open\n    this.connListeners = [];              // external listeners wanting to listen connection events\n    this.debug = false;\n    this._sockInit(host, port);\n  }\n\n\n  _sendConnEvent(val) {\n    this.connListeners.forEach(l => {\n      l && {}.toString.call(l) === '[object Function]' && l(val);\n    });\n  }\n\n  _sockInit(host, port){\n    if (!createConnection){\n      try {\n        // @ts-ignore\n        import('net').then(module => {\n          createConnection = module.createConnection;\n          this._sockSetup(host, port);\n        });\n      }catch(error){\n        if(this.debug) console.log('Unable to import net module');\n      }\n    }else {\n      this._sockSetup(host, port);\n    }\n  }\n\n  _sockSetup(host, port){\n    if(!createConnection) return;\n    try{\n      this.sock = createConnection({ 'host': host, 'port': port });\n      this.sock.setEncoding('utf8');\n      this.sock.on('connect', this._onSockOpen.bind(this));\n      this.sock.on('error', this._sockReconnect.bind(this));\n      this.sock.on('close', () => {this._sendConnEvent(false);});\n      this.sock.send = data => {this.sock.write(data);};\n    } catch (error) {\n      if(this.debug) console.log('Connection failed to ', this.sock.host + ':' + this.sock.port);\n      return;\n    }\n  }\n\n  _sockReconnect(){\n    if (this._firstConn || !this._keepAlive || this.sock.readyState == SOCKET_OPENING || this.sock.readyState == SOCKET_OPEN) return;\n    if (this._firstReConn) this._sendConnEvent(false);\n    this._firstReConn = false;\n    setTimeout(() => {\n      this.pendingOnOpen = [];\n      this._sockSetup(this.url.hostname, this.url.port);\n    }, this._reconnectTime);\n  }\n\n  _onSockOpen() {\n    this._sendConnEvent(true);\n    this._firstConn = false;\n    this.sock.on('close', this._sockReconnect.bind(this));\n    this.sock.on('data', this._processSockData.bind(this));\n    this.pendingOnOpen.forEach(cb => cb());\n    this.pendingOnOpen.length = 0;\n    this._buf = '';\n  }\n\n  _processSockData(s){\n    this._buf += s;\n    var lines = this._buf.split('\\n');\n    lines.forEach((l, idx) => {\n      if (idx < lines.length-1){\n        if (l && this._onSockRx) this._onSockRx.call(this,l);\n      } else {\n        this._buf = l;\n      }\n    });\n  }\n\n  toString(){\n    let s = '';\n    s += 'TCPConnector [' + this.sock ? this.sock.remoteAddress.toString() + ':' + this.sock.remotePort.toString() : '' + ']';\n    return s;\n  }\n\n  /**\n   * Write a string to the connector\n   * @param {string} s - string to be written out of the connector to the master\n   * @return {boolean} - true if connect was able to write or queue the string to the underlying socket\n   */\n  write(s){\n    if (!this.sock || this.sock.readyState == SOCKET_OPENING){\n      this.pendingOnOpen.push(() => {\n        this.sock.send(s+'\\n');\n      });\n      return true;\n    } else if (this.sock.readyState == SOCKET_OPEN) {\n      this.sock.send(s+'\\n');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @callback TCPConnectorReadCallback\n   * @ignore\n   * @param {string} s - incoming message string\n   */\n\n  /**\n   * Set a callback for receiving incoming strings from the connector\n   * @param {TCPConnectorReadCallback} cb - callback that is called when the connector gets a string\n   */\n  setReadCallback(cb){\n    if (cb && {}.toString.call(cb) === '[object Function]') this._onSockRx = cb;\n  }\n\n  /**\n   * Add listener for connection events\n   * @param {function} listener - a listener callback that is called when the connection is opened/closed\n   */\n  addConnectionListener(listener){\n    this.connListeners.push(listener);\n  }\n\n  /**\n   * Remove listener for connection events\n   * @param {function} listener - remove the listener for connection\n   * @return {boolean} - true if the listner was removed successfully\n   */\n  removeConnectionListener(listener) {\n    let ndx = this.connListeners.indexOf(listener);\n    if (ndx >= 0) {\n      this.connListeners.splice(ndx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Close the connector\n   */\n  close(){\n    if (!this.sock) return;\n    if (this.sock.readyState == SOCKET_OPENING) {\n      this.pendingOnOpen.push(() => {\n        this.sock.send('{\"alive\": false}\\n');\n        this.sock.removeAllListeners('connect');\n        this.sock.removeAllListeners('error');\n        this.sock.removeAllListeners('close');\n        this.sock.destroy();\n      });\n    } else if (this.sock.readyState == SOCKET_OPEN) {\n      this.sock.send('{\"alive\": false}\\n');\n      this.sock.removeAllListeners('connect');\n      this.sock.removeAllListeners('error');\n      this.sock.removeAllListeners('close');\n      this.sock.destroy();\n    }\n  }\n}\n\nconst DEFAULT_RECONNECT_TIME = 5000;       // ms, delay between retries to connect to the server.\n\n/**\n * @class\n * @ignore\n */\nclass WSConnector {\n\n  /**\n   * Create an WSConnector to connect to a fjage master over WebSockets\n   * @param {Object} opts\n   * @param {string} [opts.hostname='localhost'] - hostname/ip address of the master container to connect to\n   * @param {number} [opts.port=80] - port number of the master container to connect to\n   * @param {string} [opts.pathname=\"/\"] - path of the master container to connect to\n   * @param {boolean} [opts.keepAlive=true] - try to reconnect if the connection is lost\n   * @param {boolean} [opts.debug=false] - debug info to be logged to console?\n   * @param {number} [opts.reconnectTime=5000] - time before reconnection is attempted after an error\n   */\n  constructor(opts = {}) {\n    let host = opts.hostname || 'localhost';\n    let port = opts.port || 80;\n    this.url = new URL('ws://localhost');\n    this.url.hostname = host;\n    this.url.port = port.toString();\n    this.url.pathname = opts.pathname || '/';\n    this._keepAlive = opts.keepAlive;\n    this._reconnectTime = opts.reconnectTime || DEFAULT_RECONNECT_TIME;\n    this.debug = opts.debug || false;      // debug info to be logged to console?\n    this._firstConn = true;               // if the Gateway has managed to connect to a server before\n    this._firstReConn = true;             // if the Gateway has attempted to reconnect to a server before\n    this.pendingOnOpen = [];              // list of callbacks make as soon as gateway is open\n    this.connListeners = [];              // external listeners wanting to listen connection events\n    this._websockSetup(this.url);\n  }\n\n  _sendConnEvent(val) {\n    this.connListeners.forEach(l => {\n      l && {}.toString.call(l) === '[object Function]' && l(val);\n    });\n  }\n\n  _websockSetup(url){\n    try {\n      this.sock = new WebSocket(url);\n      this.sock.onerror = this._websockReconnect.bind(this);\n      this.sock.onopen = this._onWebsockOpen.bind(this);\n      this.sock.onclose = () => {this._sendConnEvent(false);};\n    } catch (error) {\n      if(this.debug) console.log('Connection failed to ', url);\n      return;\n    }\n  }\n\n  _websockReconnect(){\n    if (this._firstConn || !this._keepAlive || this.sock.readyState == this.sock.CONNECTING || this.sock.readyState == this.sock.OPEN) return;\n    if (this._firstReConn) this._sendConnEvent(false);\n    this._firstReConn = false;\n    if(this.debug) console.log('Reconnecting to ', this.sock.url);\n    setTimeout(() => {\n      this.pendingOnOpen = [];\n      this._websockSetup(this.sock.url);\n    }, this._reconnectTime);\n  }\n\n  _onWebsockOpen() {\n    if(this.debug) console.log('Connected to ', this.sock.url);\n    this._sendConnEvent(true);\n    this.sock.onclose = this._websockReconnect.bind(this);\n    this.sock.onmessage = event => { if (this._onWebsockRx) this._onWebsockRx.call(this,event.data); };\n    this._firstConn = false;\n    this._firstReConn = true;\n    this.pendingOnOpen.forEach(cb => cb());\n    this.pendingOnOpen.length = 0;\n  }\n\n  toString(){\n    let s = '';\n    s += 'WSConnector [' + this.sock ? this.sock.url.toString() : '' + ']';\n    return s;\n  }\n\n  /**\n   * Write a string to the connector\n   * @param {string} s - string to be written out of the connector to the master\n   */\n  write(s){\n    if (!this.sock || this.sock.readyState == this.sock.CONNECTING){\n      this.pendingOnOpen.push(() => {\n        this.sock.send(s+'\\n');\n      });\n      return true;\n    } else if (this.sock.readyState == this.sock.OPEN) {\n      this.sock.send(s+'\\n');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @callback WSConnectorReadCallback\n   * @ignore\n   * @param {string} s - incoming message string\n   */\n\n  /**\n   * Set a callback for receiving incoming strings from the connector\n   * @param {WSConnectorReadCallback} cb - callback that is called when the connector gets a string\n   * @ignore\n   */\n  setReadCallback(cb){\n    if (cb && {}.toString.call(cb) === '[object Function]') this._onWebsockRx = cb;\n  }\n\n  /**\n   * Add listener for connection events\n   * @param {function} listener - a listener callback that is called when the connection is opened/closed\n   */\n  addConnectionListener(listener){\n    this.connListeners.push(listener);\n  }\n\n  /**\n   * Remove listener for connection events\n   * @param {function} listener - remove the listener for connection\n   * @return {boolean} - true if the listner was removed successfully\n   */\n  removeConnectionListener(listener) {\n    let ndx = this.connListeners.indexOf(listener);\n    if (ndx >= 0) {\n      this.connListeners.splice(ndx, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Close the connector\n   */\n  close(){\n    if (!this.sock) return;\n    if (this.sock.readyState == this.sock.CONNECTING) {\n      this.pendingOnOpen.push(() => {\n        this.sock.send('{\"alive\": false}\\n');\n        this.sock.onclose = null;\n        this.sock.close();\n      });\n    } else if (this.sock.readyState == this.sock.OPEN) {\n      this.sock.send('{\"alive\": false}\\n');\n      this.sock.onclose = null;\n      this.sock.close();\n    }\n  }\n}\n\n/* global global Buffer */\n\n\nconst DEFAULT_QUEUE_SIZE = 128;        // max number of old unreceived messages to store\n\n/**\n * An action represented by a message. The performative actions are a subset of the\n * FIPA ACL recommendations for interagent communication.\n * @enum {string}\n */\nconst Performative = {\n  REQUEST: 'REQUEST',               // Request an action to be performed\n  AGREE: 'AGREE',                   // Agree to performing the requested action\n  REFUSE: 'REFUSE',                 // Refuse to perform the requested action\n  FAILURE: 'FAILURE',               // Notification of failure to perform a requested or agreed action\n  INFORM: 'INFORM',                 // Notification of an event\n  CONFIRM: 'CONFIRM',               // Confirm that the answer to a query is true\n  DISCONFIRM: 'DISCONFIRM',         // Confirm that the answer to a query is false\n  QUERY_IF: 'QUERY_IF',             // Query if some statement is true or false\n  NOT_UNDERSTOOD: 'NOT_UNDERSTOOD', // Notification that a message was not understood\n  CFP: 'CFP',                       // Call for proposal\n  PROPOSE: 'PROPOSE',               // Response for CFP\n  CANCEL: 'CANCEL'                  // Cancel pending request\n};\n\n/**\n * An identifier for an agent or a topic.\n * @class\n * @param {string} name - name of the agent\n * @param {boolean} [topic=false] - name of topic\n * @param {Gateway} [owner] - Gateway owner for this AgentID\n */\nclass AgentID {\n\n\n  constructor(name, topic=false, owner) {\n    this.name = name;\n    this.topic = topic;\n    this.owner = owner;\n  }\n\n  /**\n   * Gets the name of the agent or topic.\n   *\n   * @returns {string} - name of agent or topic\n   */\n  getName() {\n    return this.name;\n  }\n\n  /**\n   * Returns true if the agent id represents a topic.\n   *\n   * @returns {boolean} - true if the agent id represents a topic, false if it represents an agent\n   */\n  isTopic() {\n    return this.topic;\n  }\n\n  /**\n   * Sends a message to the agent represented by this id.\n   *\n   * @param {Message} msg - message to send\n   * @returns {void}\n   */\n  send(msg) {\n    msg.recipient = this.toJSON();\n    if (this.owner) this.owner.send(msg);\n    else throw new Error('Unowned AgentID cannot send messages');\n  }\n\n  /**\n   * Sends a request to the agent represented by this id and waits for a reponse.\n   *\n   * @param {Message} msg - request to send\n   * @param {number} [timeout=1000] - timeout in milliseconds\n   * @returns {Promise<Message>} - response\n   */\n  async request(msg, timeout=1000) {\n    msg.recipient = this.toJSON();\n    if (this.owner) return this.owner.request(msg, timeout);\n    else throw new Error('Unowned AgentID cannot send messages');\n  }\n\n  /**\n   * Gets a string representation of the agent id.\n   *\n   * @returns {string} - string representation of the agent id\n   */\n  toString() {\n    return this.toJSON() + ((this.owner && this.owner.connector) ? ` on ${this.owner.connector.url}` : '');\n  }\n\n  /**\n   * Gets a JSON string representation of the agent id.\n   *\n   * @returns {string} - JSON string representation of the agent id\n   */\n  toJSON() {\n    return (this.topic ? '#' : '') + this.name;\n  }\n\n  /**\n   * Sets parameter(s) on the Agent referred to by this AgentID.\n   *\n   * @param {(string|string[])} params - parameters name(s) to be set\n   * @param {(Object|Object[])} values - parameters value(s) to be set\n   * @param {number} [index=-1] - index of parameter(s) to be set\n   * @param {number} [timeout=5000] - timeout for the response\n   * @returns {Promise<(Object|Object[])>} - a promise which returns the new value(s) of the parameters\n   */\n  async set (params, values, index=-1, timeout=5000) {\n    if (!params) return null;\n    let msg = new ParameterReq();\n    msg.recipient = this.name;\n    if (Array.isArray(params)){\n      msg.param = params.shift();\n      msg.value = values.shift();\n      msg.requests = params.map((p, i) => {\n        return {\n          'param': p,\n          'value': values[i]\n        };\n      });\n      // Add back for generating a response\n      params.unshift(msg.param);\n    } else {\n      msg.param = params;\n      msg.value = values;\n    }\n    msg.index = Number.isInteger(index) ? index : -1;\n    const rsp = await this.owner.request(msg, timeout);\n    var ret = Array.isArray(params) ? new Array(params.length).fill(null) : null;\n    if (!rsp || rsp.perf != Performative.INFORM || !rsp.param) {\n      if (this.owner._returnNullOnFailedResponse) return ret;\n      else throw new Error(`Unable to set ${this.name}.${params} to ${values}`);\n    }\n    if (Array.isArray(params)) {\n      if (!rsp.values) rsp.values = {};\n      if (rsp.param) rsp.values[rsp.param] = rsp.value;\n      const rkeys = Object.keys(rsp.values);\n      return params.map( p => {\n        if (p.includes('.')) p = p.split('.').pop();\n        let f = rkeys.find(k => (k.includes('.') ? k.split('.').pop() : k) == p);\n        return f ? rsp.values[f] : undefined;\n      });\n    } else {\n      return rsp.value;\n    }\n  }\n\n\n  /**\n   * Gets parameter(s) on the Agent referred to by this AgentID.\n   *\n   * @param {(?string|?string[])} params - parameters name(s) to be get, null implies get value of all parameters on the Agent\n   * @param {number} [index=-1] - index of parameter(s) to be get\n   * @param {number} [timeout=5000] - timeout for the response\n   * @returns {Promise<(?Object|?Object[])>} - a promise which returns the value(s) of the parameters\n   */\n  async get(params, index=-1, timeout=5000) {\n    let msg = new ParameterReq();\n    msg.recipient = this.name;\n    if (params){\n      if (Array.isArray(params)) {\n        msg.param = params.shift();\n        msg.requests = params.map(p => {return {'param': p};});\n        // Add back for generating a response\n        params.unshift(msg.param);\n      }\n      else msg.param = params;\n    }\n    msg.index = Number.isInteger(index) ? index : -1;\n    const rsp = await this.owner.request(msg, timeout);\n    var ret = Array.isArray(params) ? new Array(params.length).fill(null) : null;\n    if (!rsp || rsp.perf != Performative.INFORM || !rsp.param) {\n      if (this.owner._returnNullOnFailedResponse) return ret;\n      else throw new Error(`Unable to get ${this.name}.${params}`);\n    }\n    // Request for listing of all parameters.\n    if (!params) {\n      if (!rsp.values) rsp.values = {};\n      if (rsp.param) rsp.values[rsp.param] = rsp.value;\n      return rsp.values;\n    } else if (Array.isArray(params)) {\n      if (!rsp.values) rsp.values = {};\n      if (rsp.param) rsp.values[rsp.param] = rsp.value;\n      const rkeys = Object.keys(rsp.values);\n      return params.map( p => {\n        if (p.includes('.')) p = p.split('.').pop();\n        let f = rkeys.find(k => (k.includes('.') ? k.split('.').pop() : k) == p);\n        return f ? rsp.values[f] : undefined;\n      });\n    } else {\n      return rsp.value;\n    }\n  }\n}\n\n// protected String msgID = UUID.randomUUID().toString();\n// protected Performative perf;\n// protected AgentID recipient;\n// protected AgentID sender = null;\n// protected String inReplyTo = null;\n// protected Long sentAt = null;\n\n/**\n * Base class for messages transmitted by one agent to another. Creates an empty message.\n * @class\n * @param {string} [msgID] - unique identifier for the message\n * @param {Performative} [perf=Performative.INFORM] - performative\n * @param {AgentID} [recipient] - recipient of the message\n * @param {AgentID} [sender] - sender of the message\n * @param {string} [inReplyTo] - message to which this response corresponds to\n * @param {Message} [inReplyTo] - message to which this response corresponds to\n * @param {number} [sentAt] - time at which the message was sent\n */\nclass Message {\n\n  constructor(inReplyTo={msgID:null, sender:null}, perf=Performative.INFORM) {\n    this.__clazz__ = 'org.arl.fjage.Message';\n    this.msgID = _guid(8);\n    this.sender = null;\n    this.recipient = inReplyTo.sender;\n    this.perf = perf;\n    this.inReplyTo = inReplyTo.msgID || null;\n  }\n\n  /**\n   * Gets a string representation of the message.\n   *\n   * @returns {string} - string representation\n   */\n  toString() {\n    let s = '';\n    let suffix = '';\n    if (!this.__clazz__) return '';\n    let clazz = this.__clazz__;\n    clazz = clazz.replace(/^.*\\./, '');\n    let perf = this.perf;\n    for (var k in this) {\n      if (k.startsWith('__')) continue;\n      if (k == 'sender') continue;\n      if (k == 'recipient') continue;\n      if (k == 'msgID') continue;\n      if (k == 'perf') continue;\n      if (k == 'inReplyTo') continue;\n      if (typeof this[k] == 'object') {\n        suffix = ' ...';\n        continue;\n      }\n      s += ' ' + k + ':' + this[k];\n    }\n    s += suffix;\n    return clazz+':'+perf+'['+s.replace(/^ /, '')+']';\n  }\n\n  // convert a message into a JSON string\n  // NOTE: we don't do any base64 encoding for TX as\n  //       we don't know what data type is intended\n  /**\n   * @private\n   *\n   * @return {string} - JSON string representation of the message\n   */\n  _serialize() {\n    let clazz = this.__clazz__ || 'org.arl.fjage.Message';\n    let data = JSON.stringify(this, (k,v) => {\n      if (k.startsWith('__')) return;\n      return v;\n    });\n    return '{ \"clazz\": \"'+clazz+'\", \"data\": '+data+' }';\n  }\n\n  // inflate a data dictionary into the message\n  /** @private */\n  _inflate(data) {\n    for (var key in data)\n      this[key] = data[key];\n  }\n\n  // convert a dictionary (usually from decoding JSON) into a message\n  /**\n   * @private\n   *\n   * @param {(string|Object)} json - JSON string or object to be converted to a message\n   * @returns {Message} - message created from the JSON string or object\n   * */\n  static _deserialize(json) {\n    let obj = null;\n    if (typeof json == 'string') {\n      try {\n        obj = JSON.parse(json);\n      }catch(e){\n        return null;\n      }\n    } else obj = json;\n    let qclazz = obj.clazz;\n    let clazz = qclazz.replace(/^.*\\./, '');\n    let rv = MessageClass[clazz] ? new MessageClass[clazz] : new Message();\n    rv.__clazz__ = qclazz;\n    rv._inflate(obj.data);\n    return rv;\n  }\n}\n\n/**\n * A message class that can convey generic messages represented by key-value pairs.\n * @class\n * @extends Message\n */\nclass GenericMessage extends Message {\n  /**\n   * Creates an empty generic message.\n   */\n  constructor() {\n    super();\n    this.__clazz__ = 'org.arl.fjage.GenericMessage';\n  }\n}\n\n/**\n * A gateway for connecting to a fjage master container. The new version of the constructor\n * uses an options object instead of individual parameters. The old version with\n *\n *\n * @class\n * @param {Object} opts\n * @param {string} [opts.hostname=\"localhost\"] - hostname/ip address of the master container to connect to\n * @param {number} [opts.port=1100]          - port number of the master container to connect to\n * @param {string} [opts.pathname=\"\"]        - path of the master container to connect to (for WebSockets)\n * @param {string} [opts.keepAlive=true]     - try to reconnect if the connection is lost\n * @param {number} [opts.queueSize=128]      - size of the queue of received messages that haven't been consumed yet\n * @param {number} [opts.timeout=1000]       - timeout for fjage level messages in ms\n * @param {boolean} [opts.returnNullOnFailedResponse=true] - return null instead of throwing an error when a parameter is not found\n * @param {boolean} [opts.cancelPendingOnDisconnect=false] - cancel pending requests on disconnect\n */\nclass Gateway {\n\n  constructor(opts = {}) {\n    // Similar to Object.assign but also overwrites `undefined` and empty strings with defaults\n    for (var key in GATEWAY_DEFAULTS){\n      if (opts[key] == undefined || opts[key] === '') opts[key] = GATEWAY_DEFAULTS[key];\n    }\n    var url = DEFAULT_URL;\n    url.hostname = opts.hostname;\n    url.port = opts.port;\n    url.pathname = opts.pathname;\n    let existing = this._getGWCache(url);\n    if (existing) return existing;\n    this._timeout = opts.timeout;         // timeout for fjage level messages (agentForService etc)\n    this._keepAlive = opts.keepAlive;     // reconnect if connection gets closed/errored\n    this._queueSize = opts.queueSize;     // size of queue\n    this._returnNullOnFailedResponse = opts.returnNullOnFailedResponse; // null or error\n    this._cancelPendingOnDisconnect = opts.cancelPendingOnDisconnect; // cancel pending requests on disconnect\n    this.pending = {};                    // msgid to callback mapping for pending requests to server\n    this.subscriptions = {};              // hashset for all topics that are subscribed\n    this.listeners = {};                  // list of callbacks that want to listen to incoming messages\n    this.eventListeners = {};             // external listeners wanting to listen internal events\n    this.queue = [];                      // incoming message queue\n    this.connected = false;               // connection status\n    this.debug = false;                   // debug info to be logged to console?\n    this.aid = new AgentID('gateway-'+_guid(4));         // gateway agent name\n    this.connector = this._createConnector(url);\n    this._addGWCache(this);\n  }\n\n  /**\n   * Sends an event to all registered listeners of the given type.\n   * @private\n   * @param {string} type - type of event\n   * @param {Object|Message|string} val - value to be sent to the listeners\n   */\n  _sendEvent(type, val) {\n    if (!Array.isArray(this.eventListeners[type])) return;\n    this.eventListeners[type].forEach(l => {\n      if (l && {}.toString.call(l) === '[object Function]'){\n        try {\n          l(val);\n        } catch (error) {\n          console.warn('Error in event listener : ' + error);\n        }\n      }\n    });\n  }\n\n  /**\n   * Sends the message to all registered receivers.\n   *\n   * @private\n   * @param {Message} msg\n   * @returns {boolean} - true if the message was consumed by any listener\n   */\n  _sendReceivers(msg) {\n    for (var lid in this.listeners){\n      try {\n        if (this.listeners[lid] && this.listeners[lid](msg)) return true;\n      } catch (error) {\n        console.warn('Error in listener : ' + error);\n      }\n    }\n    return false;\n  }\n\n\n  /**\n   * @private\n   * @param {string} data - stringfied JSON data received from the master container to be processed\n   * @returns {void}\n   */\n  _onMsgRx(data) {\n    var obj;\n    if (this.debug) console.log('< '+data);\n    this._sendEvent('rx', data);\n    try {\n      obj = JSON.parse(data, _decodeBase64);\n    }catch(e){\n      return;\n    }\n    this._sendEvent('rxp', obj);\n    if ('id' in obj && obj.id in this.pending) {\n      // response to a pending request to master\n      this.pending[obj.id](obj);\n      delete this.pending[obj.id];\n    } else if (obj.action == 'send') {\n      // incoming message from master\n      // @ts-ignore\n      let msg = Message._deserialize(obj.message);\n      if (!msg) return;\n      this._sendEvent('rxmsg', msg);\n      if ((msg.recipient == this.aid.toJSON() )|| this.subscriptions[msg.recipient]) {\n        // send to any \"message\" listeners\n        this._sendEvent('message', msg);\n        // send message to receivers, if not consumed, add to queue\n        if(!this._sendReceivers(msg)) {\n          if (this.queue.length >= this._queueSize) this.queue.shift();\n          this.queue.push(msg);\n        }\n      }\n    } else {\n      // respond to standard requests that every container must\n      let rsp = { id: obj.id, inResponseTo: obj.action };\n      switch (obj.action) {\n      case 'agents':\n        rsp.agentIDs = [this.aid.getName()];\n        break;\n      case 'containsAgent':\n        rsp.answer = (obj.agentID == this.aid.getName());\n        break;\n      case 'services':\n        rsp.services = [];\n        break;\n      case 'agentForService':\n        rsp.agentID = '';\n        break;\n      case 'agentsForService':\n        rsp.agentIDs = [];\n        break;\n      default:\n        rsp = undefined;\n      }\n      if (rsp) this._msgTx(rsp);\n    }\n  }\n\n  /**\n   * Sends a message out to the master container.\n   * @private\n   * @param {string|Object} s - JSON object (either stringified or not) to be sent to the master container\n   * @returns {boolean} - true if the message was sent successfully\n   */\n  _msgTx(s) {\n    if (typeof s != 'string' && !(s instanceof String)) s = JSON.stringify(s);\n    if(this.debug) console.log('> '+s);\n    this._sendEvent('tx', s);\n    return this.connector.write(s);\n  }\n\n  /**\n   * @private\n   * @param {Object} rq - request to be sent to the master container as a JSON object\n   * @returns {Promise<Object>} - a promise which returns the response from the master container\n   */\n  _msgTxRx(rq) {\n    rq.id = _guid(8);\n    return new Promise(resolve => {\n      let timer = setTimeout(() => {\n        delete this.pending[rq.id];\n        if (this.debug) console.log('Receive Timeout : ' + JSON.stringify(rq));\n        resolve();\n      }, 8*this._timeout);\n      this.pending[rq.id] = rsp => {\n        clearTimeout(timer);\n        resolve(rsp);\n      };\n      if (!this._msgTx.call(this,rq)) {\n        clearTimeout(timer);\n        delete this.pending[rq.id];\n        if (this.debug) console.log('Transmit Timeout : ' +  JSON.stringify(rq));\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * @private\n   * @param {URL} url - URL object of the master container to connect to\n   * @returns {TCPConnector|WSConnector} - connector object to connect to the master container\n   */\n  _createConnector(url){\n    let conn;\n    if (url.protocol.startsWith('ws')){\n      conn =  new WSConnector({\n        'hostname':url.hostname,\n        'port':parseInt(url.port),\n        'pathname':url.pathname,\n        'keepAlive': this._keepAlive,\n        'debug': this.debug\n      });\n    }else if (url.protocol.startsWith('tcp')){\n      conn = new TCPConnector({\n        'hostname':url.hostname,\n        'port':parseInt(url.port),\n        'keepAlive': this._keepAlive,\n        'debug': this.debug\n      });\n    } else return null;\n    conn.setReadCallback(this._onMsgRx.bind(this));\n    conn.addConnectionListener(state => {\n      this.connected = !!state;\n      if (state == true){\n        this.flush();\n        this.connector.write('{\"alive\": true}');\n        this._update_watch();\n      } else {\n        if (this._cancelPendingOnDisconnect) {\n          this._sendReceivers(null);\n          this.flush();\n        }\n      }\n      this._sendEvent('conn', state);\n    });\n    return conn;\n  }\n\n  /**\n   * Checks if the object is a constructor.\n   *\n   * @private\n   * @param {Object} value - an object to be checked if it is a constructor\n   * @returns {boolean} - if the object is a constructor\n   */\n  _isConstructor(value) {\n    try {\n      new new Proxy(value, {construct() { return {}; }});\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n   * Matches a message with a filter.\n   * @private\n   * @param {string|Object|function} filter - filter to be matched\n   * @param {Message} msg - message to be matched to the filter\n   * @returns {boolean} - true if the message matches the filter\n   */\n  _matchMessage(filter, msg){\n    if (typeof filter == 'string' || filter instanceof String) {\n      return 'inReplyTo' in msg && msg.inReplyTo == filter;\n    } else if (Object.prototype.hasOwnProperty.call(filter, 'msgID')) {\n      return 'inReplyTo' in msg && msg.inReplyTo == filter.msgID;\n    } else if (filter.__proto__.name == 'Message' || filter.__proto__.__proto__.name == 'Message') {\n      return filter.__clazz__ == msg.__clazz__;\n    } else if (typeof filter == 'function' && !this._isConstructor(filter)) {\n      try {\n        return filter(msg);\n      }catch(e){\n        console.warn('Error in filter : ' + e);\n        return false;\n      }\n    } else {\n      return msg instanceof filter;\n    }\n  }\n\n  /**\n   * Gets the next message from the queue that matches the filter.\n   * @private\n   * @param {string|Object|function} filter - filter to be matched\n   */\n  _getMessageFromQueue(filter) {\n    if (!this.queue.length) return;\n    if (!filter) return this.queue.shift();\n    let matchedMsg = this.queue.find( msg => this._matchMessage(filter, msg));\n    if (matchedMsg) this.queue.splice(this.queue.indexOf(matchedMsg), 1);\n    return matchedMsg;\n  }\n\n  /**\n   * Gets a cached gateway object for the given URL (if it exists).\n   * @private\n   * @param {URL} url - URL object of the master container to connect to\n   * @returns {Gateway|void} - gateway object for the given URL\n   */\n  _getGWCache(url){\n    if (!gObj.fjage || !gObj.fjage.gateways) return null;\n    var f = gObj.fjage.gateways.filter(g => g.connector.url.toString() == url.toString());\n    if (f.length ) return f[0];\n    return null;\n  }\n\n  /**\n   * Adds a gateway object to the cache if it doesn't already exist.\n   * @private\n   * @param {Gateway} gw - gateway object to be added to the cache\n   */\n  _addGWCache(gw){\n    if (!gObj.fjage || !gObj.fjage.gateways) return;\n    gObj.fjage.gateways.push(gw);\n  }\n\n  /**\n   * Removes a gateway object from the cache if it exists.\n   * @private\n   * @param {Gateway} gw - gateway object to be removed from the cache\n   */\n  _removeGWCache(gw){\n    if (!gObj.fjage || !gObj.fjage.gateways) return;\n    var index = gObj.fjage.gateways.indexOf(gw);\n    if (index != null) gObj.fjage.gateways.splice(index,1);\n  }\n\n  /** @private */\n  _update_watch() {\n    let watch = Object.keys(this.subscriptions);\n    watch.push(this.aid.getName());\n    let rq = { action: 'wantsMessagesFor', agentIDs: watch };\n    this._msgTx(rq);\n  }\n\n  /**\n   * Add an event listener to listen to various events happening on this Gateway\n   *\n   * @param {string} type - type of event to be listened to\n   * @param {function} listener - new callback/function to be called when the event happens\n   * @returns {void}\n   */\n  addEventListener(type, listener) {\n    if (!Array.isArray(this.eventListeners[type])){\n      this.eventListeners[type] = [];\n    }\n    this.eventListeners[type].push(listener);\n  }\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {string} type - type of event the listener was for\n   * @param {function} listener - callback/function which was to be called when the event happens\n   * @returns {void}\n   */\n  removeEventListener(type, listener) {\n    if (!this.eventListeners[type]) return;\n    let ndx = this.eventListeners[type].indexOf(listener);\n    if (ndx >= 0) this.eventListeners[type].splice(ndx, 1);\n  }\n\n  /**\n   * Add a new listener to listen to all {Message}s sent to this Gateway\n   *\n   * @param {function} listener - new callback/function to be called when a {Message} is received\n   * @returns {void}\n   */\n  addMessageListener(listener) {\n    this.addEventListener('message',listener);\n  }\n\n  /**\n   * Remove a message listener.\n   *\n   * @param {function} listener - removes a previously registered listener/callback\n   * @returns {void}\n   */\n  removeMessageListener(listener) {\n    this.removeEventListener('message', listener);\n  }\n\n  /**\n   * Add a new listener to get notified when the connection to master is created and terminated.\n   *\n   * @param {function} listener - new callback/function to be called connection to master is created and terminated\n   * @returns {void}\n   */\n  addConnListener(listener) {\n    this.addEventListener('conn', listener);\n  }\n\n  /**\n   * Remove a connection listener.\n   *\n   * @param {function} listener - removes a previously registered listener/callback\n   * @returns {void}\n   */\n  removeConnListener(listener) {\n    this.removeEventListener('conn', listener);\n  }\n\n  /**\n   * Gets the agent ID associated with the gateway.\n   *\n   * @returns {AgentID} - agent ID\n   */\n  getAgentID() {\n    return this.aid;\n  }\n\n  /**\n   * Get an AgentID for a given agent name.\n   *\n   * @param {string} name - name of agent\n   * @returns {AgentID} - AgentID for the given name\n   */\n  agent(name) {\n    return new AgentID(name, false, this);\n  }\n\n  /**\n   * Returns an object representing the named topic.\n   *\n   * @param {string|AgentID} topic - name of the topic or AgentID\n   * @param {string} [topic2] - name of the topic if the topic param is an AgentID\n   * @returns {AgentID} - object representing the topic\n   */\n  topic(topic, topic2) {\n    if (typeof topic == 'string' || topic instanceof String) return new AgentID(topic, true, this);\n    if (topic instanceof AgentID) {\n      if (topic.isTopic()) return topic;\n      return new AgentID(topic.getName()+(topic2 ? '__' + topic2 : '')+'__ntf', true, this);\n    }\n  }\n\n  /**\n   * Subscribes the gateway to receive all messages sent to the given topic.\n   *\n   * @param {AgentID} topic - the topic to subscribe to\n   * @returns {boolean} - true if the subscription is successful, false otherwise\n   */\n  subscribe(topic) {\n    if (!topic.isTopic()) topic = new AgentID(topic.getName() + '__ntf', true, this);\n    this.subscriptions[topic.toJSON()] = true;\n    this._update_watch();\n    return true;\n  }\n\n  /**\n   * Unsubscribes the gateway from a given topic.\n   *\n   * @param {AgentID} topic - the topic to unsubscribe\n   * @returns {void}\n   */\n  unsubscribe(topic) {\n    if (!topic.isTopic()) topic = new AgentID(topic.getName() + '__ntf', true, this);\n    delete this.subscriptions[topic.toJSON()];\n    this._update_watch();\n  }\n\n  /**\n   * Gets a list of all agents in the container.\n   * @returns {Promise<AgentID[]>} - a promise which returns an array of all agent ids when resolved\n   */\n  async agents() {\n    let rq = { action: 'agents' };\n    let rsp = await this._msgTxRx(rq);\n    if (!rsp || !Array.isArray(rsp.agentIDs)) throw new Error('Unable to get agents');\n    return rsp.agentIDs.map(aid => new AgentID(aid, false, this));\n  }\n\n  /**\n   * Check if an agent with a given name exists in the container.\n   *\n   * @param {AgentID|String} agentID - the agent id to check\n   * @returns {Promise<boolean>} - a promise which returns true if the agent exists when resolved\n   */\n  async containsAgent(agentID) {\n    let rq = { action: 'containsAgent', agentID: agentID instanceof AgentID ? agentID.getName() : agentID };\n    let rsp = await this._msgTxRx(rq);\n    if (!rsp) throw new Error('Unable to check if agent exists');\n    return !!rsp.answer;\n  }\n\n  /**\n   * Finds an agent that provides a named service. If multiple agents are registered\n   * to provide a given service, any of the agents' id may be returned.\n   *\n   * @param {string} service - the named service of interest\n   * @returns {Promise<?AgentID>} - a promise which returns an agent id for an agent that provides the service when resolved\n   */\n  async agentForService(service) {\n    let rq = { action: 'agentForService', service: service };\n    let rsp = await this._msgTxRx(rq);\n    if (!rsp) {\n      if (this._returnNullOnFailedResponse) return null;\n      else throw new Error('Unable to get agent for service');\n    }\n    if (!rsp.agentID) return null;\n    return new AgentID(rsp.agentID, false, this);\n  }\n\n  /**\n   * Finds all agents that provides a named service.\n   *\n   * @param {string} service - the named service of interest\n   * @returns {Promise<?AgentID[]>} - a promise which returns an array of all agent ids that provides the service when resolved\n   */\n  async agentsForService(service) {\n    let rq = { action: 'agentsForService', service: service };\n    let rsp = await this._msgTxRx(rq);\n    let aids = [];\n    if (!rsp) {\n      if (this._returnNullOnFailedResponse) return aids;\n      else throw new Error('Unable to get agents for service');\n    }\n    if (!Array.isArray(rsp.agentIDs)) return aids;\n    for (var i = 0; i < rsp.agentIDs.length; i++)\n      aids.push(new AgentID(rsp.agentIDs[i], false, this));\n    return aids;\n  }\n\n  /**\n   * Sends a message to the recipient indicated in the message. The recipient\n   * may be an agent or a topic.\n   *\n   * @param {Message} msg - message to be sent\n   * @returns {boolean} - if sending was successful\n   */\n  send(msg) {\n    msg.sender = this.aid.toJSON();\n    if (msg.perf == '') {\n      if (msg.__clazz__.endsWith('Req')) msg.perf = Performative.REQUEST;\n      else msg.perf = Performative.INFORM;\n    }\n    this._sendEvent('txmsg', msg);\n    let rq = JSON.stringify({ action: 'send', relay: true, message: '###MSG###' });\n    // @ts-ignore\n    rq = rq.replace('\"###MSG###\"', msg._serialize());\n    return !!this._msgTx(rq);\n  }\n\n  /**\n   * Flush the Gateway queue for all pending messages. This drops all the pending messages.\n   * @returns {void}\n   *\n   */\n  flush() {\n    this.queue.length = 0;\n  }\n\n  /**\n   * Sends a request and waits for a response. This method returns a {Promise} which resolves when a response\n   * is received or if no response is received after the timeout.\n   *\n   * @param {Message} msg - message to send\n   * @param {number} [timeout=1000] - timeout in milliseconds\n   * @returns {Promise<Message|void>} - a promise which resolves with the received response message, null on timeout\n   */\n  async request(msg, timeout=1000) {\n    this.send(msg);\n    return this.receive(msg, timeout);\n  }\n\n  /**\n   * Returns a response message received by the gateway. This method returns a {Promise} which resolves when\n   * a response is received or if no response is received after the timeout.\n   *\n   * @param {function|Message|typeof Message} filter - original message to which a response is expected, or a MessageClass of the type\n   * of message to match, or a closure to use to match against the message\n   * @param {number} [timeout=0] - timeout in milliseconds\n   * @returns {Promise<Message|void>} - received response message, null on timeout\n   */\n  async receive(filter, timeout=0) {\n    return new Promise(resolve => {\n      let msg = this._getMessageFromQueue.call(this,filter);\n      if (msg) {\n        resolve(msg);\n        return;\n      }\n      if (timeout == 0) {\n        if (this.debug) console.log('Receive Timeout : ' + filter);\n        resolve();\n        return;\n      }\n      let lid = _guid(8);\n      let timer;\n      if (timeout > 0){\n        timer = setTimeout(() => {\n          this.listeners[lid] && delete this.listeners[lid];\n          if (this.debug) console.log('Receive Timeout : ' + filter);\n          resolve();\n        }, timeout);\n      }\n      // listener for each pending receive\n      this.listeners[lid] = msg => {\n        // skip if the message does not match the filter\n        if (msg && !this._matchMessage(filter, msg)) return false;\n        if(timer) clearTimeout(timer);\n        // if the message matches the filter or is null, delete listener clear timer and resolve\n        this.listeners[lid] && delete this.listeners[lid];\n        resolve(msg);\n        return true;\n      };\n    });\n  }\n\n  /**\n   * Closes the gateway. The gateway functionality may not longer be accessed after\n   * this method is called.\n   * @returns {void}\n   */\n  close() {\n    this.connector.close();\n    this._removeGWCache(this);\n  }\n\n}\n\n/**\n * Services supported by fjage agents.\n */\nconst Services = {\n  SHELL : 'org.arl.fjage.shell.Services.SHELL'\n};\n\n/**\n * Creates a unqualified message class based on a fully qualified name.\n * @param {string} name - fully qualified name of the message class to be created\n * @param {typeof Message} [parent] - class of the parent MessageClass to inherit from\n * @constructs Message\n * @example\n * const ParameterReq = MessageClass('org.arl.fjage.param.ParameterReq');\n * let pReq = new ParameterReq()\n */\nfunction MessageClass(name, parent=Message) {\n  let sname = name.replace(/^.*\\./, '');\n  if (MessageClass[sname]) return MessageClass[sname];\n  let cls = class extends parent {\n    /**\n     * @param {{ [x: string]: any; }} params\n     */\n    constructor(params) {\n      super();\n      this.__clazz__ = name;\n      if (params){\n        const keys = Object.keys(params);\n        for (let k of keys) {\n          this[k] = params[k];\n        }\n      }\n      if (name.endsWith('Req')) this.perf = Performative.REQUEST;\n    }\n  };\n  cls.__clazz__ = name;\n  MessageClass[sname] = cls;\n  return cls;\n}\n\n////// private utilities\n\n// generate random ID with length 4*len characters\n/** @private */\nfunction _guid(len) {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  let s = s4();\n  for (var i = 0; i < len-1; i++)\n    s += s4();\n  return s;\n}\n\n// convert from base 64 to array\n/** @private */\nfunction _b64toArray(base64, dtype, littleEndian=true) {\n  let s = gObj.atob(base64);\n  let len = s.length;\n  let bytes = new Uint8Array(len);\n  for (var i = 0; i < len; i++)\n    bytes[i] = s.charCodeAt(i);\n  let rv = [];\n  let view = new DataView(bytes.buffer);\n  switch (dtype) {\n  case '[B': // byte array\n    for (i = 0; i < len; i++)\n      rv.push(view.getUint8(i));\n    break;\n  case '[S': // short array\n    for (i = 0; i < len; i+=2)\n      rv.push(view.getInt16(i, littleEndian));\n    break;\n  case '[I': // integer array\n    for (i = 0; i < len; i+=4)\n      rv.push(view.getInt32(i, littleEndian));\n    break;\n  case '[J': // long array\n    for (i = 0; i < len; i+=8)\n      rv.push(view.getBigInt64(i, littleEndian));\n    break;\n  case '[F': // float array\n    for (i = 0; i < len; i+=4)\n      rv.push(view.getFloat32(i, littleEndian));\n    break;\n  case '[D': // double array\n    for (i = 0; i < len; i+=8)\n      rv.push(view.getFloat64(i, littleEndian));\n    break;\n  default:\n    return;\n  }\n  return rv;\n}\n\n// base 64 JSON decoder\n/** @private */\nfunction _decodeBase64(k, d) {\n  if (d === null) {\n    return null;\n  }\n  if (typeof d == 'object' && 'clazz' in d) {\n    let clazz = d.clazz;\n    if (clazz.startsWith('[') && clazz.length == 2 && 'data' in d) {\n      let x = _b64toArray(d.data, d.clazz);\n      if (x) d = x;\n    }\n  }\n  return d;\n}\n\n////// global\n\nconst GATEWAY_DEFAULTS = {};\n\n/** @type {Window & globalThis & Object} */\nlet gObj = {};\nlet DEFAULT_URL;\nif (isBrowser || isWebWorker){\n  gObj = window;\n  Object.assign(GATEWAY_DEFAULTS, {\n    'hostname': gObj.location.hostname,\n    'port': gObj.location.port,\n    'pathname' : '/ws/',\n    'timeout': 1000,\n    'keepAlive' : true,\n    'queueSize': DEFAULT_QUEUE_SIZE,\n    'returnNullOnFailedResponse': true,\n    'cancelPendingOnDisconnect': false\n  });\n  DEFAULT_URL = new URL('ws://localhost');\n  // Enable caching of Gateways\n  if (typeof gObj.fjage === 'undefined') gObj.fjage = {};\n  if (typeof gObj.fjage.gateways == 'undefined') gObj.fjage.gateways = [];\n} else if (isJsDom || isNode){\n  gObj = global;\n  Object.assign(GATEWAY_DEFAULTS, {\n    'hostname': 'localhost',\n    'port': '1100',\n    'pathname': '',\n    'timeout': 1000,\n    'keepAlive' : true,\n    'queueSize': DEFAULT_QUEUE_SIZE,\n    'returnNullOnFailedResponse': true,\n    'cancelPendingOnDisconnect': false\n  });\n  DEFAULT_URL = new URL('tcp://localhost');\n  gObj.atob = a => Buffer.from(a, 'base64').toString('binary');\n}\n\n/**\n * @typedef {Object} ParameterReq.Entry\n * @property {string} param - parameter name\n * @property {Object} value - parameter value\n * @exports ParameterReq.Entry\n */\n\n\n/**\n * A message that requests one or more parameters of an agent.\n * @typedef {Message} ParameterReq\n * @property {string} param - parameters name to be get/set if only a single parameter is to be get/set\n * @property {Object} value - parameters value to be set if only a single parameter is to be set\n * @property {Array<ParameterReq.Entry>} requests - a list of multiple parameters to be get/set\n * @property {number} [index=-1] - index of parameter(s) to be set\n * @exports ParameterReq\n */\nconst ParameterReq = MessageClass('org.arl.fjage.param.ParameterReq');\n\nexport { AgentID, Gateway, GenericMessage, Message, MessageClass, ParameterReq, Performative, Services };\n","import {AgentID, MessageClass, Services, Gateway} from 'fjage';\n\nconst DatagramReq = MessageClass('org.arl.unet.DatagramReq');\nconst DatagramNtf = MessageClass('org.arl.unet.DatagramNtf');\nconst TxFrameReq = MessageClass('org.arl.unet.phy.TxFrameReq', DatagramReq);\nconst RxFrameNtf = MessageClass('org.arl.unet.phy.RxFrameNtf', DatagramNtf);\nconst BasebandSignal = MessageClass('org.arl.unet.bb.BasebandSignal');\n\nlet UnetServices = {\n  'NODE_INFO': 'org.arl.unet.Services.NODE_INFO',\n  'ADDRESS_RESOLUTION': 'org.arl.unet.Services.ADDRESS_RESOLUTION',\n  'DATAGRAM': 'org.arl.unet.Services.DATAGRAM',\n  'PHYSICAL': 'org.arl.unet.Services.PHYSICAL',\n  'RANGING': 'org.arl.unet.Services.RANGING',\n  'BASEBAND': 'org.arl.unet.Services.BASEBAND',\n  'LINK': 'org.arl.unet.Services.LINK',\n  'MAC': 'org.arl.unet.Services.MAC',\n  'ROUTING': 'org.arl.unet.Services.ROUTING',\n  'ROUTE_MAINTENANCE': 'org.arl.unet.Services.ROUTE_MAINTENANCE',\n  'TRANSPORT': 'org.arl.unet.Services.TRANSPORT',\n  'REMOTE': 'org.arl.unet.Services.REMOTE',\n  'STATE_MANAGER': 'org.arl.unet.Services.STATE_MANAGER',\n  'DEVICE_INFO': 'org.arl.unet.Services.DEVICE_INFO',\n  'DOA': 'org.arl.unet.Services.DOA',\n  'SCHEDULER':'org.arl.unet.Services.SCHEDULER'\n};\n\nObject.assign(Services, UnetServices);\n\n/**\n * Well-known protocol number assignments used in UnetStack\n * @typedef {Object.<string, number>} Protocol\n */\nlet Protocol = {\n  'DATA' : 0,               // Protocol number for user application data.\n  'RANGING' : 1,            // Protocol number for use by ranging agents.\n  'LINK' : 2,               // Protocol number for use by link agents.\n  'REMOTE' : 3,             // Protocol number for use by remote management agents.\n  'MAC' : 4,                // Protocol number for use by MAC protocol agents.\n  'ROUTING' : 5,            // Protocol number for use by routing agents.\n  'TRANSPORT' : 6,          // Protocol number for use by transport agents.\n  'ROUTE_MAINTENANCE' : 7,   // Protocol number for use by route maintenance agents.\n  'LINK2' : 8,              // Protocol number for use by secondary link agents.\n  'USER' : 32,              // Lowest protocol number allowable for user protocols.\n  'MAX' : 63,               // Largest protocol number allowable.\n};\n\n/**\n * Well-known protocol Messages used in UnetStack\n * @typedef {Object.<string, MessageClass>} UnetMessages\n */\nlet UnetMessages = {\n  // unet\n  'TestReportNtf'          : MessageClass('org.arl.unet.TestReportNtf'),\n  'AbnormalTerminationNtf' : MessageClass('org.arl.unet.AbnormalTerminationNtf'),\n  'CapabilityListRsp'      : MessageClass('org.arl.unet.CapabilityListRsp'),\n  'CapabilityReq'          : MessageClass('org.arl.unet.CapabilityReq'),\n  'ClearReq'               : MessageClass('org.arl.unet.ClearReq'),\n  'DatagramCancelReq'      : MessageClass('org.arl.unet.DatagramCancelReq'),\n  'DatagramDeliveryNtf'    : MessageClass('org.arl.unet.DatagramDeliveryNtf'),\n  'DatagramFailureNtf'     : MessageClass('org.arl.unet.DatagramFailureNtf'),\n  'DatagramNtf'            : MessageClass('org.arl.unet.DatagramNtf'),\n  'DatagramProgressNtf'    : MessageClass('org.arl.unet.DatagramProgressNtf'),\n  'DatagramReq'            : MessageClass('org.arl.unet.DatagramReq'),\n  'ParamChangeNtf'         : MessageClass('org.arl.unet.ParamChangeNtf'),\n  'RefuseRsp'              : MessageClass('org.arl.unet.RefuseRsp'),\n  'FailureNtf'             : MessageClass('org.arl.unet.FailureNtf'),\n\n  // net\n  'DatagramTraceReq'       : MessageClass('org.arl.unet.net.DatagramTraceReq'),\n  'RouteDiscoveryReq'      : MessageClass('org.arl.unet.net.RouteDiscoveryReq'),\n  'RouteTraceReq'          : MessageClass('org.arl.unet.net.RouteTraceReq'),\n  'RouteDiscoveryNtf'      : MessageClass('org.arl.unet.net.RouteDiscoveryNtf'),\n  'RouteTraceNtf'          : MessageClass('org.arl.unet.net.RouteTraceNtf'),\n\n  // phy\n  'FecDecodeReq'           : MessageClass('org.arl.unet.phy.FecDecodeReq'),\n  'RxSWiG1FrameNtf'        : MessageClass('org.arl.unet.phy.RxSWiG1FrameNtf', RxFrameNtf),\n  'TxSWiG1FrameReq'        : MessageClass('org.arl.unet.phy.TxSWiG1FrameReq', TxFrameReq),\n  'RxJanusFrameNtf'        : MessageClass('org.arl.unet.phy.RxJanusFrameNtf', RxFrameNtf),\n  'TxJanusFrameReq'        : MessageClass('org.arl.unet.phy.TxJanusFrameReq', TxFrameReq),\n  'BadFrameNtf'            : MessageClass('org.arl.unet.phy.BadFrameNtf'),\n  'BadRangeNtf'            : MessageClass('org.arl.unet.phy.BadRangeNtf'),\n  'ClearSyncReq'           : MessageClass('org.arl.unet.phy.ClearSyncReq'),\n  'CollisionNtf'           : MessageClass('org.arl.unet.phy.CollisionNtf'),\n  'RxFrameNtf'             : MessageClass('org.arl.unet.phy.RxFrameNtf', DatagramNtf),\n  'RxFrameStartNtf'        : MessageClass('org.arl.unet.phy.RxFrameStartNtf'),\n  'SyncInfoReq'            : MessageClass('org.arl.unet.phy.SyncInfoReq'),\n  'SyncInfoRsp'            : MessageClass('org.arl.unet.phy.SyncInfoRsp'),\n  'TxFrameNtf'             : MessageClass('org.arl.unet.phy.TxFrameNtf'),\n  'TxFrameReq'             : MessageClass('org.arl.unet.phy.TxFrameReq', DatagramReq),\n  'TxFrameStartNtf'        : MessageClass('org.arl.unet.phy.TxFrameStartNtf'),\n  'TxRawFrameReq'          : MessageClass('org.arl.unet.phy.TxRawFrameReq'),\n\n  // addr\n  'AddressAllocReq'        : MessageClass('org.arl.unet.addr.AddressAllocReq'),\n  'AddressAllocRsp'        : MessageClass('org.arl.unet.addr.AddressAllocRsp'),\n  'AddressResolutionReq'   : MessageClass('org.arl.unet.addr.AddressResolutionReq'),\n  'AddressResolutionRsp'   : MessageClass('org.arl.unet.addr.AddressResolutionRsp'),\n\n  // bb\n  'BasebandSignal'         : MessageClass('org.arl.unet.bb.BasebandSignal'),\n  'RecordBasebandSignalReq' : MessageClass('org.arl.unet.bb.RecordBasebandSignalReq'),\n  'RxBasebandSignalNtf'    : MessageClass('org.arl.unet.bb.RxBasebandSignalNtf', BasebandSignal),\n  'TxBasebandSignalReq'    : MessageClass('org.arl.unet.bb.TxBasebandSignalReq', BasebandSignal),\n\n  // link\n  'LinkStatusNtf'          : MessageClass('org.arl.unet.link.LinkStatusNtf'),\n\n  // localization\n  'RangeNtf'               : MessageClass('org.arl.unet.localization.RangeNtf'),\n  'RangeReq'               : MessageClass('org.arl.unet.localization.RangeReq'),\n  'BeaconReq'              : MessageClass('org.arl.unet.localization.BeaconReq'),\n  'RespondReq'             : MessageClass('org.arl.unet.localization.RespondReq'),\n  'InterrogationNtf'       : MessageClass('org.arl.unet.localization.InterrogationNtf'),\n\n\n  // mac\n  'ReservationAcceptReq'   : MessageClass('org.arl.unet.mac.ReservationAcceptReq'),\n  'ReservationCancelReq'   : MessageClass('org.arl.unet.mac.ReservationCancelReq'),\n  'ReservationReq'         : MessageClass('org.arl.unet.mac.ReservationReq'),\n  'ReservationRsp'         : MessageClass('org.arl.unet.mac.ReservationRsp'),\n  'ReservationStatusNtf'   : MessageClass('org.arl.unet.mac.ReservationStatusNtf'),\n  'RxAckNtf'               : MessageClass('org.arl.unet.mac.RxAckNtf'),\n  'TxAckReq'               : MessageClass('org.arl.unet.mac.TxAckReq'),\n\n\n  // remote\n  'RemoteExecReq'          : MessageClass('org.arl.unet.remote.RemoteExecReq'),\n  'RemoteFailureNtf'       : MessageClass('org.arl.unet.remote.RemoteFailureNtf'),\n  'RemoteFileGetReq'       : MessageClass('org.arl.unet.remote.RemoteFileGetReq'),\n  'RemoteFileNtf'          : MessageClass('org.arl.unet.remote.RemoteFileNtf'),\n  'RemoteFilePutReq'       : MessageClass('org.arl.unet.remote.RemoteFilePutReq'),\n  'RemoteSuccessNtf'       : MessageClass('org.arl.unet.remote.RemoteSuccessNtf'),\n  'RemoteTextNtf'          : MessageClass('org.arl.unet.remote.RemoteTextNtf'),\n  'RemoteTextReq'          : MessageClass('org.arl.unet.remote.RemoteTextReq'),\n\n  // scheduler\n  'AddScheduledSleepReq'   : MessageClass('org.arl.unet.scheduler.AddScheduledSleepReq'),\n  'GetSleepScheduleReq'    : MessageClass('org.arl.unet.scheduler.GetSleepScheduleReq'),\n  'RemoveScheduledSleepReq' : MessageClass('org.arl.unet.scheduler.RemoveScheduledSleepReq'),\n  'SleepScheduleRsp'       : MessageClass('org.arl.unet.scheduler.SleepScheduleRsp'),\n  'WakeFromSleepNtf'       : MessageClass('org.arl.unet.scheduler.WakeFromSleepNtf'),\n\n  // state\n  'ClearStateReq'          : MessageClass('org.arl.unet.state.ClearStateReq'),\n  'SaveStateReq'           : MessageClass('org.arl.unet.state.SaveStateReq')\n};\n\n/**\n  * Convert coordinates from a local coordinates to GPS coordinate\n  * @param {Array} origin - Local coordinate system's origin as `[latitude, longitude]`\n  * @param {Number} x - X coordinate of the local coordinate to be converted\n  * @param {Number} y - Y coordinate of the local coordinate to be converted\n  * @returns {Array} - GPS coordinates (in decimal degrees) as `[latitude, longitude]`\n  */\n\nexport function toGps(origin, x, y) {\n  let coords = [] ;\n  let [xScale,yScale] = _initConv(origin[0]);\n  coords[1] = x/xScale + origin[1];\n  coords[0] = y/yScale + origin[0];\n  return coords;\n}\n\n/**\n  * Convert coordinates from a GPS coordinates to local coordinate\n  * @param {Array} origin - Local coordinate system's origin as `[latitude, longitude]`\n  * @param {Number} lat - Latitude of the GPS coordinate to be converted\n  * @param {Number} lon - Longitude of the GPS coordinate to be converted\n  * @returns {Array} - GPS coordinates (in decimal degrees) as `[latitude, longitude]`\n  */\nexport function toLocal(origin, lat, lon) {\n  let pos = [];\n  let [xScale,yScale] = _initConv(origin[0]);\n  pos[0] = (lon-origin[1]) * xScale;\n  pos[1] = (lat-origin[0]) * yScale;\n  return pos;\n}\n\nfunction _initConv(lat){\n  let rlat = lat * Math.PI/180;\n  let yScale = 111132.92 - 559.82*Math.cos(2*rlat) + 1.175*Math.cos(4*rlat) - 0.0023*Math.cos(6*rlat);\n  let xScale = 111412.84*Math.cos(rlat) - 93.5*Math.cos(3*rlat) + 0.118*Math.cos(5*rlat);\n  return [xScale, yScale];\n}\n\n/**\n * A message which requests the transmission of the datagram from the Unet\n *\n * @typedef {Message} DatagramReq\n * @property {number[]} data - data as an Array of bytes\n * @property {number} from - from/source node address\n * @property {number} to - to/destination node address\n * @property {number} protocol - protocol number to be used to send this Datagram\n * @property {boolean} reliability - true if Datagram should be reliable, false if unreliable\n * @property {number} ttl - time-to-live for the datagram. Time-to-live is advisory, and an agent may choose it ignore it\n */\n\n/**\n * Notification of received datagram message received by the Unet node.\n *\n * @typedef {Message} DatagramNtf\n * @property {number[]} data - data as an Array of bytes\n * @property {number} from - from/source node address\n * @property {number} to - to/destination node address\n * @property {number} protocol - protocol number to be used to send this Datagram\n * @property {number} ttl - time-to-live for the datagram. Time-to-live is advisory, and an agent may choose it ignore it\n */\n\n/**\n * An identifier for an agent or a topic.\n * @external AgentID\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n * Services supported by fjage agents.\n * @external Services\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n *  An action represented by a message.\n * @external Performative\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n * Function to creates a unqualified message class based on a fully qualified name.\n * @external MessageClass\n * @see {@link https://org-arl.github.io/fjage/jsdoc/|fjåge.js Documentation}\n */\n\n/**\n * A caching CachingAgentID which caches Agent parameters locally.\n *\n * @class\n * @extends AgentID\n * @param {string | AgentID} name - name of the agent or an AgentID to copy\n * @param {boolean} topic - name of topic\n * @param {Gateway} owner - Gateway owner for this AgentID\n * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n *\n*/\nclass CachingAgentID extends AgentID {\n\n  constructor(name, topic, owner, greedy=true) {\n    if (name instanceof AgentID) {\n      super(name.getName(), name.topic, name.owner);\n    } else {\n      super(name, topic, owner);\n    }\n    this.greedy = greedy;\n    this.cache = {};\n    this.specialParams = ['name', 'version'];\n  }\n\n  /**\n   * Sets parameter(s) on the Agent referred to by this AgentID, and caches the parameter(s).\n   *\n   * @param {(string|string[])} params - parameters name(s) to be set\n   * @param {(Object|Object[])} values - parameters value(s) to be set\n   * @param {number} [index=-1] - index of parameter(s) to be set\n   * @param {number} [timeout=5000] - timeout for the response\n   * @returns {Promise<(Object|Object[])>} - a promise which returns the new value(s) of the parameters\n   */\n  async set(params, values, index=-1, timeout=5000) {\n    let s = await super.set(params, values, index, timeout);\n    this._updateCache(params, s, index);\n    return s;\n  }\n\n  /**\n   * Gets parameter(s) on the Agent referred to by this AgentID, getting them from the cache if possible.\n   *\n   * @param {(string|string[])} params - parameters name(s) to be fetched\n   * @param {number} [index=-1] - index of parameter(s) to be fetched\n   * @param {number} [timeout=5000] - timeout for the response\n   * @param {number} [maxage=5000] - maximum age of the cached result to retreive\n   * @returns {Promise<(Object|Object[])>} - a promise which returns the value(s) of the parameters\n   */\n  async get(params, index=-1, timeout=5000, maxage=5000) {\n    if (this._isCached(params, index, maxage)) return this._getCache(params, index);\n    if (this.greedy &&\n      !(Array.isArray(params) && [...new Set([...params, ...this.specialParams])].length!=0) &&\n      !this.specialParams.includes(params)) {\n      let rsp = await super.get(null, index, timeout);\n      this._updateCache(null, rsp, index);\n      if (!rsp) return Array.isArray(params) ? new Array(params.length).fill(null) : null;\n      if (!params) return rsp;\n      else if (Array.isArray(params)) {\n        return params.map(p => {\n          let f = Object.keys(rsp).find(rv => this._toNamed(rv) === p);\n          return f ? rsp[f] : null;\n        });\n      } else {\n        let f = Object.keys(rsp).find(rv => this._toNamed(rv) === params);\n        return f ? rsp[f] : null;\n      }\n    } else{\n      let r = await super.get(params, index, timeout);\n      this._updateCache(params, r, index);\n      return r;\n    }\n  }\n\n  _updateCache(params, vals, index) {\n    if (vals == null || Array.isArray(vals) && vals.every(v => v == null)) return;\n    if (params == null) {\n      params = Object.keys(vals);\n      vals = Object.values(vals);\n    } else if (!Array.isArray(params)) params = [params];\n    if (!Array.isArray(vals)) vals = [vals];\n    params = params.map(this._toNamed);\n    if (this.cache[index.toString()] === undefined) this.cache[index.toString()] = {};\n    let c = this.cache[index.toString()];\n    for (let i = 0; i < params.length; i++) {\n      if (c[params[i]] === undefined) c[params[i]] = {};\n      c[params[i]].value = vals[i];\n      c[params[i]].ctime = Date.now();\n    }\n  }\n\n  _isCached(params, index, maxage) {\n    if (maxage <= 0) return false;\n    if (params == null) return false;\n    let c = this.cache[index.toString()];\n    if (!c) {\n      return false;\n    }\n    if (!Array.isArray(params)) params = [params];\n    const rv = params.every(p => {\n      p = this._toNamed(p);\n      return (p in c) && (Date.now() - c[p].ctime <= maxage);\n    });\n    return rv;\n  }\n\n  _getCache(params, index) {\n    let c = this.cache[index.toString()];\n    if (!c) return null;\n    if (!Array.isArray(params)){\n      if (params in c) return c[params].value;\n      return null;\n    }else {\n      return params.map(p => p in c ? c[p].value : null);\n    }\n  }\n\n  _toNamed(param) {\n    const idx = param.lastIndexOf('.');\n    if (idx < 0) return param;\n    else return param.slice(idx+1);\n  }\n\n}\n\n\nclass CachingGateway extends Gateway{\n\n  /**\n   * Get an AgentID for a given agent name.\n   *\n   * @param {string} name - name of agent\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {AgentID|CachingAgentID} - AgentID for the given name\n   */\n  agent(name, caching=true, greedy=true) {\n    const aid = super.agent(name);\n    return caching ? new CachingAgentID(aid, null, null, greedy) : aid;\n  }\n\n  /**\n   * Returns an object representing the named topic.\n   *\n   * @param {string|AgentID} topic - name of the topic or AgentID\n   * @param {string} topic2 - name of the topic if the topic param is an AgentID\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {AgentID|CachingAgentID} - object representing the topic\n   */\n  topic(topic, topic2, caching=true, greedy=true) {\n    const aid = super.topic(topic, topic2);\n    return caching ? new CachingAgentID(aid, null, null, greedy) : aid;\n  }\n\n  /**\n   * Finds an agent that provides a named service. If multiple agents are registered\n   * to provide a given service, any of the agents' id may be returned.\n   *\n   * @param {string} service - the named service of interest\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {Promise<?AgentID|CachingAgentID>} - a promise which returns an agent id for an agent that provides the service when resolved\n   */\n  async agentForService(service, caching=true, greedy=true) {\n    const aid = await super.agentForService(service);\n    if (!aid) return aid;\n    return caching ? new CachingAgentID(aid, null, null, greedy) : aid;\n  }\n\n  /**\n   * Finds all agents that provides a named service.\n   *\n   * @param {string} service - the named service of interest\n   * @param {Boolean} [caching=true] - if the AgentID should cache parameters\n   * @param {Boolean} [greedy=true] - greedily fetches and caches all parameters if this Agent\n   * @returns {Promise<?AgentID|CachingAgentID[]>} - a promise which returns an array of all agent ids that provides the service when resolved\n   */\n  async agentsForService(service, caching=true, greedy=true) {\n    const aids = await super.agentsForService(service);\n    return caching ? aids.map(a => new CachingAgentID(a, null, null, greedy)) : aids;\n  }\n}\n\nexport {AgentID, Services, UnetMessages, Protocol, CachingGateway, CachingAgentID};\n","import {Gateway, Performative} from 'fjage';\nimport {Services, UnetMessages, Protocol} from './unetutils';\n\nconst REQUEST_TIMEOUT = 1000;\n\nconst AddressResolutionReq = UnetMessages.AddressResolutionReq;\nconst DatagramReq = UnetMessages.DatagramReq;\nconst DatagramNtf = UnetMessages.DatagramNtf;\nconst RxFrameNtf = UnetMessages.RxFrameNtf;\n\n/**\n * Creates a new UnetSocket to connect to a running Unet instance. This constructor returns a\n * {@link Promise} instead of the constructed UnetSocket object. Use `await` or `.then()` to get\n * a reference to the UnetSocket object. Based on if this is run in a Browser or Node.js,\n * it will internally connect over WebSockets or TCP respectively.\n *\n *\n * @class UnetSocket\n * @param {string} [hostname] - hostname/ip address of the master container to connect to\n * @param {string} [port] - port number of the master container to connect to\n * @param {string} [path='']  - path of the master container to connect to (for WebSockets)\n * @returns {Promise<UnetSocket>} - Promise which resolves to the UnetSocket object being constructed\n *\n * @example\n * let socket = await new UnetSocket('localhost', 8081, '/ws/');\n */\nexport default class UnetSocket {\n\n  constructor(hostname, port, path='') {\n    return (async () => {\n      this.gw = new Gateway({\n        hostname : hostname,\n        port : port,\n        path : path\n      });\n      this.localProtocol = -1;\n      this.remoteAddress = -1;\n      this.remoteProtocol = Protocol.DATA;\n      this.timeout = 0;\n      this.provider = null;\n      const alist = await this.gw.agentsForService(Services.DATAGRAM);\n      alist.forEach(a => {this.gw.subscribe(this.gw.topic(a));});\n      return this;\n    })();\n  }\n\n  /**\n   * Closes the socket. The socket functionality may not longer be accessed after this method is called.\n   * @returns {void}\n   */\n  close() {\n    this.gw.close();\n    this.gw = null;\n  }\n\n  /**\n   * Checks if a socket is closed.\n   * @returns {boolean} - true if closed, false if open\n   */\n  isClosed() {\n    return this.gw == null;\n  }\n\n  /**\n   * Binds a socket to listen to a specific protocol datagrams.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are reserved protocols\n   * and cannot be bound. Unbound sockets listen to all unreserved\n   * @param {Protocol} protocol - protocol number to listen for\n   * @returns {boolean} - true on success, false on failure\n   */\n  bind(protocol) {\n    if (protocol == Protocol.DATA || (protocol >= Protocol.USER && protocol <= Protocol.MAX)) {\n      this.localProtocol = protocol;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Unbinds a socket so that it listens to all unreserved protocols.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are considered reserved.\n   * @returns {void}\n   */\n  unbind() { this.localProtocol = -1;}\n\n  /**\n   * Checks if a socket is bound.\n   * @returns {boolean} - true if bound to a protocol, false if unbound\n   */\n  isBound() { return this.localProtocol >= 0;}\n\n  /**\n   * Sets the default destination address and destination protocol number for datagrams sent\n   * using this socket. The defaults can be overridden for specific send() calls.\n   * The default protcol number when a socket is opened is Protcol.DATA.\n   * The default node address is undefined.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are considered reserved,\n   * and cannot be used for sending datagrams using the socket.\n   *\n   * @param {number} to - default destination node address\n   * @param {Protocol} protocol - default protocol number\n   * @returns {boolean} - true on success, false on failure\n   */\n  connect(to, protocol) {\n    if (to >= 0 && (protocol == Protocol.DATA || (protocol >= Protocol.USER && protocol <= Protocol.MAX))) {\n      this.remoteAddress = to;\n      this.remoteProtocol = protocol;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Resets the default destination address to undefined, and the default protocol number\n   * to Protocol.DATA.\n   * @returns {void}\n   */\n  disconnect() {\n    this.remoteAddress = -1;\n    this.remoteProtocol = 0;\n  }\n\n  /**\n   * Checks if a socket is connected, i.e., has a default destination address and protocol number.\n   * @returns {boolean} - true if connected, false otherwise\n   */\n  isConnected() { return this.remoteAddress >= 0; }\n\n  /**\n   * Gets the local node address of the Unet node connected to.\n   * @returns {Promise<int>} - local node address, or -1 on error\n   */\n  async getLocalAddress() {\n    if (this.gw == null) return -1;\n    const nodeinfo = await this.gw.agentForService(Services.NODE_INFO);\n    if (nodeinfo == null) return -1;\n    const addr = await nodeinfo.get('address');\n    return addr != null ? addr : -1;\n  }\n\n  /**\n   * Gets the protocol number that the socket is bound to.\n   * @returns {number}} - protocol number if socket is bound, -1 otherwise\n   */\n  getLocalProtocol() { return this.localProtocol; }\n\n  /**\n   * Gets the default destination node address for a connected socket.\n   * @returns {number}} - default destination node address if connected, -1 otherwise\n   */\n  getRemoteAddress() { return this.remoteAddress; }\n\n  /**\n   * Gets the default transmission protocol number.\n   * @returns {number}} - default protocol number used to transmit a datagram\n   */\n  getRemoteProtocol() { return this.remoteProtocol; }\n\n  /**\n   * Sets the timeout for datagram reception. A timeout of 0 means the\n   * {@link UnetSocket#receive|receive method} will check any appropriate\n   * Datagram has already been received (and is cached) else return immediately.\n   *\n   * @param {number} ms - timeout in milliseconds\n   * @returns {void}\n   */\n  setTimeout(ms) {\n    if (ms < 0) ms = 0;\n    this.timeout = ms;\n  }\n\n  /**\n   * Gets the timeout for datagram reception.\n   * @returns {number} - timeout in milliseconds\n   */\n  getTimeout() { return this.timeout; }\n\n  /**\n   * Transmits a datagram to the specified node address using the specified protocol.\n   * Protocol numbers between Protocol.DATA+1 to Protocol.USER-1 are considered reserved,\n   * and cannot be used for sending datagrams using the socket.\n   * @param {number[]|DatagramReq} data - data to be sent over the socket as an Array of bytes or DatagramReq\n   * @param {number} to - destination node address\n   * @param {number} protocol - protocol number\n   * @returns {Promise<boolean>} - true if the Unet node agreed to send out the Datagram, false otherwise\n   */\n  async send(data, to=this.remoteAddress, protocol=this.remoteProtocol) {\n    if (to < 0 || this.gw == null) return false;\n    var req;\n    if (Array.isArray(data)){\n      req = new DatagramReq();\n      req.data = data;\n      req.to = to;\n      req.protocol = protocol;\n    } else if (data instanceof DatagramReq){\n      req = data;\n    } else {\n      return false;\n    }\n    let p = req.protocol;\n    if (p != Protocol.DATA && (p < Protocol.USER || p > Protocol.MAX)) return false;\n    if (req.recipient == null) {\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.TRANSPORT);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.ROUTING);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.LINK);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.PHYSICAL);\n      if (this.provider == null) this.provider = await this.gw.agentForService(Services.DATAGRAM);\n      if (this.provider == null) return false;\n      req.recipient = this.provider;\n    }\n    const rsp = await this.gw.request(req, REQUEST_TIMEOUT);\n    return (rsp != null && rsp.perf == Performative.AGREE);\n  }\n\n  /**\n   * Receives a datagram sent to the local node and the bound protocol number. If the socket is unbound,\n   * then datagrams with all unreserved protocols are received. Any broadcast datagrams are also received.\n   *\n   * @returns {Promise<?DatagramNtf>} - datagram received by the socket\n   */\n  async receive() {\n    if (this.gw == null) return null;\n    return await this.gw.receive(msg => {\n      if (msg.__clazz__ != DatagramNtf.__clazz__ && msg.__clazz__ != RxFrameNtf.__clazz__ ) return false;\n      let p = msg.protocol;\n      if (p == Protocol.DATA || p >= Protocol.USER) {\n        return this.localProtocol < 0 || this.localProtocol == p;\n      }\n      return false;\n    }, this.timeout);\n  }\n\n  /**\n   * Gets a Gateway to provide low-level access to UnetStack.\n   * @returns {Gateway} - underlying fjage Gateway supporting this socket\n   */\n  getGateway() { return this.gw; }\n\n  /**\n   * Gets an AgentID providing a specified service for low-level access to UnetStack\n   * @param {string} svc - the named service of interest\n   * @param {Boolean} caching - if the AgentID should cache parameters\n   * @returns {Promise<?AgentID>} - a promise which returns an {@link AgentID} that provides the service when resolved\n   */\n  async agentForService(svc, caching=true) {\n    if (this.gw == null) return null;\n    return await this.gw.agentForService(svc, caching);\n  }\n\n  /**\n   *\n   * @param {string} svc - the named service of interest\n   * @param {Boolean} caching - if the AgentID should cache parameters\n   * @returns {Promise<AgentID[]>} - a promise which returns an array of {@link AgentID|AgentIDs} that provides the service when resolved\n   */\n  async agentsForService(svc, caching=true) {\n    if (this.gw == null) return null;\n    return await this.gw.agentsForService(svc, caching``);\n  }\n\n  /**\n   * Gets a named AgentID for low-level access to UnetStack.\n   * @param {string} name - name of agent\n   * @param {Boolean} caching - if the AgentID should cache parameters\n   * @returns {AgentID} - AgentID for the given name\n   */\n  agent(name, caching=true) {\n    if (this.gw == null) return null;\n    return this.gw.agent(name, caching);\n  }\n\n  /**\n   * Resolve node name to node address.\n   * @param {string} nodeName - name of the node to resolve\n   * @returns {Promise<?number>} - address of the node, or null if unable to resolve\n   */\n  async host(nodeName) {\n    const arp = await this.agentForService(Services.ADDRESS_RESOLUTION);\n    if (arp == null) return null;\n    const req = new AddressResolutionReq(nodeName);\n    req.name = nodeName;\n    req.recipient = arp;\n    const rsp = await this.gw.request(req, REQUEST_TIMEOUT);\n    if (rsp == null || ! Object.prototype.hasOwnProperty.call(rsp, 'address')) return null;\n    return rsp.address;\n  }\n}"],"names":["isBrowser","window","document","isNode","process","versions","node","isWebWorker","self","constructor","name","isJsDom","navigator","userAgent","includes","Deno","core","SOCKET_OPEN","SOCKET_OPENING","createConnection","TCPConnector","opts","host","hostname","port","this","_keepAlive","keepAlive","_reconnectTime","reconnectTime","url","URL","toString","_buf","_firstConn","_firstReConn","pendingOnOpen","connListeners","debug","_sockInit","_sendConnEvent","val","forEach","l","call","_sockSetup","import","then","module","error","console","log","sock","setEncoding","on","_onSockOpen","bind","_sockReconnect","send","data","write","readyState","setTimeout","_processSockData","cb","length","s","lines","split","idx","_onSockRx","remoteAddress","remotePort","push","setReadCallback","addConnectionListener","listener","removeConnectionListener","ndx","indexOf","splice","close","removeAllListeners","destroy","WSConnector","pathname","_websockSetup","WebSocket","onerror","_websockReconnect","onopen","_onWebsockOpen","onclose","CONNECTING","OPEN","onmessage","event","_onWebsockRx","Performative","REQUEST","AGREE","REFUSE","FAILURE","INFORM","CONFIRM","DISCONFIRM","QUERY_IF","NOT_UNDERSTOOD","CFP","PROPOSE","CANCEL","AgentID","topic","owner","getName","isTopic","msg","recipient","toJSON","Error","request","timeout","connector","set","params","values","index","ParameterReq","Array","isArray","param","shift","value","requests","map","p","i","unshift","Number","isInteger","rsp","ret","fill","perf","_returnNullOnFailedResponse","rkeys","Object","keys","pop","f","find","k","undefined","get","Message","inReplyTo","msgID","sender","__clazz__","_guid","suffix","clazz","replace","startsWith","_serialize","JSON","stringify","v","_inflate","key","_deserialize","json","obj","parse","e","qclazz","rv","MessageClass","Gateway","GATEWAY_DEFAULTS","DEFAULT_URL","existing","_getGWCache","_timeout","_queueSize","queueSize","returnNullOnFailedResponse","_cancelPendingOnDisconnect","cancelPendingOnDisconnect","pending","subscriptions","listeners","eventListeners","queue","connected","aid","_createConnector","_addGWCache","_sendEvent","type","warn","_sendReceivers","lid","_onMsgRx","_decodeBase64","id","action","message","inResponseTo","agentIDs","answer","agentID","services","_msgTx","String","_msgTxRx","rq","Promise","resolve","timer","clearTimeout","conn","protocol","parseInt","state","flush","_update_watch","_isConstructor","Proxy","construct","err","_matchMessage","filter","prototype","hasOwnProperty","__proto__","_getMessageFromQueue","matchedMsg","gObj","fjage","gateways","g","gw","_removeGWCache","watch","addEventListener","removeEventListener","addMessageListener","removeMessageListener","addConnListener","removeConnListener","getAgentID","agent","topic2","subscribe","unsubscribe","agents","containsAgent","agentForService","service","agentsForService","aids","endsWith","relay","receive","Services","SHELL","parent","sname","cls","super","len","s4","Math","floor","random","substring","d","x","base64","dtype","littleEndian","atob","bytes","Uint8Array","charCodeAt","view","DataView","buffer","getUint8","getInt16","getInt32","getBigInt64","getFloat32","getFloat64","_b64toArray","assign","location","global","a","Buffer","from","DatagramReq","DatagramNtf","TxFrameReq","RxFrameNtf","BasebandSignal","NODE_INFO","ADDRESS_RESOLUTION","DATAGRAM","PHYSICAL","RANGING","BASEBAND","LINK","MAC","ROUTING","ROUTE_MAINTENANCE","TRANSPORT","REMOTE","STATE_MANAGER","DEVICE_INFO","DOA","SCHEDULER","Protocol","DATA","LINK2","USER","MAX","UnetMessages","TestReportNtf","AbnormalTerminationNtf","CapabilityListRsp","CapabilityReq","ClearReq","DatagramCancelReq","DatagramDeliveryNtf","DatagramFailureNtf","DatagramProgressNtf","ParamChangeNtf","RefuseRsp","FailureNtf","DatagramTraceReq","RouteDiscoveryReq","RouteTraceReq","RouteDiscoveryNtf","RouteTraceNtf","FecDecodeReq","RxSWiG1FrameNtf","TxSWiG1FrameReq","RxJanusFrameNtf","TxJanusFrameReq","BadFrameNtf","BadRangeNtf","ClearSyncReq","CollisionNtf","RxFrameStartNtf","SyncInfoReq","SyncInfoRsp","TxFrameNtf","TxFrameStartNtf","TxRawFrameReq","AddressAllocReq","AddressAllocRsp","AddressResolutionReq","AddressResolutionRsp","RecordBasebandSignalReq","RxBasebandSignalNtf","TxBasebandSignalReq","LinkStatusNtf","RangeNtf","RangeReq","BeaconReq","RespondReq","InterrogationNtf","ReservationAcceptReq","ReservationCancelReq","ReservationReq","ReservationRsp","ReservationStatusNtf","RxAckNtf","TxAckReq","RemoteExecReq","RemoteFailureNtf","RemoteFileGetReq","RemoteFileNtf","RemoteFilePutReq","RemoteSuccessNtf","RemoteTextNtf","RemoteTextReq","AddScheduledSleepReq","GetSleepScheduleReq","RemoveScheduledSleepReq","SleepScheduleRsp","WakeFromSleepNtf","ClearStateReq","SaveStateReq","_initConv","lat","rlat","PI","yScale","cos","CachingAgentID","greedy","cache","specialParams","_updateCache","maxage","_isCached","_getCache","Set","r","_toNamed","vals","every","c","ctime","Date","now","lastIndexOf","slice","caching","path","localProtocol","remoteProtocol","provider","isClosed","unbind","isBound","connect","to","disconnect","isConnected","getLocalAddress","nodeinfo","addr","getLocalProtocol","getRemoteAddress","getRemoteProtocol","ms","getTimeout","req","getGateway","svc","nodeName","arp","address","origin","y","coords","xScale","lon","pos"],"mappings":"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","x_google_ignoreList":[0]}